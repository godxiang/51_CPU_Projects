#include "main.h"
#include "idcard.h"
#include "uart.h"

unsigned char const code HEART_BEAT[]={0x55, 0xaa, 0x00, 0x01, 0x03, 0x71, 0x00, 0x01, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00, 0x16};

void main(void)

{
init_Uart();
IO_Init();
Timer0_Init();
while(1){
Op_IdCard();
Delay_ms(400);											//等待串口接收数据完毕
UART3_Proccess();										//串口数据处理
CommonMessProce();									//通用消息处理函数
}
}

/***********************************************
函数名称：Timer0_Init
功    能：定时器0初始化函数
入口参数：无
返 回 值：无	
备    注：无
************************************************/
void Timer0_Init(void)
{
AUXR &=0x7f;		//定时器0的速度是传统8051的速度，12分频。
TMOD &=0xf0;      	//T0工作于十六位自动重装定时方式
//使用位操作，避免对其他定时器产生影响
TL0=0x00;		 	//定时初值50ms	 11.0592MHz
TH0=0x70; 		
ET0=1;			  	//使能T0中断
EA=1;			  	//使能总中断
TR0=1;	  	      	//运行T0  
}
/***********************************************
函数名称：Timer0_ISR
功    能：定时器0中断服务函数
入口参数：无
返 回 值：无	
备    注：无
************************************************/
void Timer0_ISR(void) interrupt 1 using 2
{
static unsigned int T0_Cnt=0;	
unsigned char i;
unsigned char *dat;
dat = HEART_BEAT;
					//使用静态计数器,每次调用该中断函数时，
					//静态计数器都能保持上一次的计数值。
					//如果不使用静态计数器，每次调用该中断函数时
					//该计数器初值都是0，计数值就无法累加。
					//这里不需要重装定时初值 
T0_Cnt++;	//计数器加1
if(T0_Cnt==50*40)					//定时1000ms
{
	T0_Cnt=0;
	//ET0=0;			  				//安全起见可以先关闭定时器，避免再次中断，丢失当前栈中的数据
	IE2 &= ~0x08;						//关闭串口3中断
	for(i=0;i<sizeof(HEART_BEAT);i++){
		S3BUF=*(dat++);
		Delay_ms(5);
		while(!S3CON & 0x02);
		S3CON &= ~0x02;         //清除S3TI位
	}
	IE2 |= 0x08;							//开启串口3中断
	//ET0=1;			  					//使能T0中断
}
}


/***********************************************
函数名称：IO_Init
功    能：单片机IO端口模式初始化
入口参数：无
返 回 值：无	
备    注：STC15W4K32S4系列A版单片机部分端口复位后
			不是准双向口,需要设置才能正常使用
************************************************/
void IO_Init(void)
{

//将P04 P05 P06 P07设置为开漏口
//因为单片机为5V端口，W25Q64为3.3V端口，为了实现电平匹配
//将单片机设置为开漏结构，由外部上拉到3.3V。
P4M0 = 0;
P4M1 = 0;																							//继电器端口初始化
P0M1 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;  
P0M0 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;
//分析
//  1<<0等价于0x01 即 0000 0001
//  1<<1等价于0x02 即 0000 0010
//  1<<2等价于0x04 即 0000 0100
//  1<<3等价于0x08 即 0000 1000
//  以此类推1<<n 即第n位为1，其余位是0

//  x |=(1<<n)  即对x执行按位取或 
//  即x中的第n位置为1，不改变其他位状态  

//  y &=~(1<<n)  即将1<<n按位取反，然后对y按位取与 
//  即y中的第n位置为0，不改变其他位状态  
P2M0 = 0x30;				//00110000
P2M1 = 0xc0;				//11000000			设定P2.0 P2.1 P2.2 P2.3 为高阻输入 P2.4 P2.5为输出  P2.6 P2.7为高阻输入
P1M0 = 0x20;			  //00000100
P1M1 = 0x10;				//00001000			设定P1.2为输出,设定P1.3为高阻输入

//P10 P14复位后为强推挽输出、强上拉，
//防止不当操作导致端口损坏，初始化为准双向口 
//将P10 P14设置为准双向口
//P1M1 &=~( (1<<0) | (1<<4) );  
//P1M0 &=~( (1<<0) | (1<<4) );

}
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART_TEST0
OBJECT MODULE PLACED IN .\Objects\UART_TEST0.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE UART_TEST0.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\UART_TEST0.lst) TABS(2) OBJECT(.\Objects\UART_TEST0.obj)

line level    source

   1          //包含文件定义
   2          #include "stc15w4k32s4.h"
   3          //#include <stc.h>
   4          #include "intrins.h"
   5          #include "string.h"
   6          //串口相关常量定义
   7          #define  FOSC              22118400L   //系统频率11059200L 22118400L
   8          #define  Uart1_MaxString   32          //串口1最大接收缓冲区字符数量(0-31)共32个字符
   9          #define  Uart2_MaxString   32          //串口2最大接收缓冲区字符数量(0-31)共32个字符
  10          //串口相关变量定义
  11          char           Uart1_Data[Uart1_MaxString];   //串口1接收字串
  12          unsigned char  Uart1_String_P;                //串口1接收字串位置指针
  13          bit            Uart1_busy;                    //串口1正在发送标记,1，正在发送，0，发送完成
  14          unsigned char  Uart1_ParitySet;               //串口1奇偶校验方式 0不校验 1奇校验 2偶校验 3始终1 4始终0
  15          bit            Uart1_Parity;                  //串口1接收到的奇偶校验状态 1,0
  16          bit            Uart1_Parity_out;              //串口1验证接收到的奇偶校验状态 1,验证,0验证错误
  17          char           Uart2_Data[Uart1_MaxString];   //串口2接收字串
  18          unsigned char  Uart2_String_P;                //串口2接收字串位置指针
  19          bit            Uart2_busy;                    //串口2正在发送标记,1，正在发送，0，发送完成
  20          unsigned char  Uart2_ParitySet;               //串口2奇偶校验方式 0不校验 1奇校验 2偶校验 3始终1 4始终0
  21          bit            Uart2_Parity;                  //串口2接收到的奇偶校验状态 1,0
  22          bit            Uart2_Parity_out;              //串口2验证接收到的奇偶校验状态 1,验证,0验证错误
  23          //Uart1包含函数申明
  24          void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx); //串口1波特率和时基源设置函数
  25          void Uart1_SendData(unsigned char Uart1_dat);                  //串口1单字符发送函数
  26          void Uart1_SendString(char *s);                          //串口1字符串发送函数
  27          //void Uart1_Isr() interrupt 4 using 1;                    //串口1中断服务函数
  28          void Uart2_Setup(unsigned long Uart2_Baud);              //串口2波特率
  29          void Uart2_SendData(unsigned char Uart2_dat);                  //串口2单字符发送函数
  30          void Uart2_SendString(char *s);                          //串口2字符串发送函数
  31          //void Uart1_Isr() interrupt 4 using 1;                    //串口2中断服务函数
  32          /*串口编程示范============================================================================
  33          Uart1_String_P=0;                //串口1接收字串下标归0
  34          Uart1_ParitySet=1;               //串口1使用9位可变波特率方式，校验方式为奇校验
  35          Uart1_Setup(9600,0);             //串口1波特率为9600bps，时基源选择定时器1
  36          Uart1_SendString("hello word");  //串口1发送数据，英文字母 hello word
  37          Uart2_String_P=0;                //串口2接收字串下标归0
  38          Uart2_ParitySet=1;               //串口2使用9位可变波特率方式，校验方式为奇校验
  39          Uart2_Setup(9600);               //串口2波特率为9600bps
  40          Uart2_SendString("hello word");  //串口2发送数据，英文字母 hello word
  41          =======================================================================================*/
  42          /*********************************************************
  43          ** 函数名称: void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx) 
  44          ** 功能描述: 初始化串口函数
  45          ** 输　  入: unsigned long Uart1_Baud,bit Uart1_Tx
  46          ** 输　  出: 无
  47          ** 全局变量: PCON,SCON,TMOD,AUXR,TCON,TH1,
  48          ** 调用模块: 
  49          ** 备    注:时钟为22118400Hz
  50                      参数1:波特率设置,300;600;1200;2400;4800;9600;19200
  51                      参数2:计数器选择,0,定时器1;1,独立波特率
  52          **********************************************************/
  53          void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx) 
  54          {
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 2   

  55   1      unsigned int Uart1_Brt;
  56   1      //时基源设置-------------------------------------------------
  57   1      if(Uart1_Tx)
  58   1          {
  59   2      AUXR |= 0x01;  //串口1选择独立波特率发生器
  60   2      }
  61   1      else
  62   1          {
  63   2      AUXR &= 0xFE;  //串口1选择定时器1做波特率发生器
  64   2      }
  65   1      //校验方式设置-------------------------------------------------
  66   1      switch (Uart1_ParitySet)
  67   1          {//判断校验方式
  68   2          case 1:
  69   2              {//9位串口, 奇校验 Uart1_ParitySet=1;   //校验位初值状态标记置1
  70   3              SCON=0xD8;           //9位波特率可变,允许接收,TB8待发第9位初始置1
  71   3              break;
  72   3              }
  73   2          case 2:
  74   2              {//9位串口, 偶校验 Uart1_ParitySet=2;   //校验位初值状态标记置2
  75   3              SCON=0xD4;           //9位波特率可变,允许接收,RB8待收第9位初始置1
  76   3              break;
  77   3              }
  78   2          case 3:
  79   2              {//9位串口, 掩码校验 校验值始终为 1 Uart1_ParitySet=3;   //校验位初值状态标记置3
  80   3              SCON|=0xD8;         //9位波特率可变,允许接收,TB8待发第9位初始置1
  81   3              break;
  82   3              }
  83   2          case 4:
  84   2              {//9位串口, 空校验 校验值始终为 0 Uart1_ParitySet=4;   //校验位初值状态标记置4
  85   3              SCON=0xD4;          //9位波特率可变,允许接收,RB8待收第9位初始置1
  86   3              break;
  87   3              }
  88   2          default:
  89   2              {//8位串口, 无校验 Uart1_ParitySet=0;   //校验位初值状态标记置0
  90   3              SCON&=0x5F;         //清除第5位,第7位
  91   3              SCON|=0x50;         //8位波特率可变,允许接收
  92   3              break;
  93   3              }
  94   2          }
  95   1      //波特率设置并开始运行串口-------------------------------------------------
  96   1      //时钟为22118400Hz
  97   1      Uart1_Brt=FOSC/32/Uart1_Baud;
  98   1      if(Uart1_Brt>255)
  99   1          {//如果重装值>255,使用12T模式12分频
 100   2          if(Uart1_Tx)
 101   2              {//如果使用独立波特率发生器
 102   3              //PCON |= 0x80;                                 //串口1波特率加倍
 103   3              //PCON &= 0x7f;                                 //串口1波特率不加倍
 104   3              AUXR &= 0xFB;                                 //独立波特率使用12T模式
 105   3              //AUXR |= 0x04;                                 //独立波特率使用1T模式
 106   3              BRT = 256-Uart1_Brt/12;                       //独立波特率发生器初值设置
*** ERROR C202 IN LINE 106 OF UART_TEST0.c: 'BRT': undefined identifier
 107   3              AUXR|= 0x10;                                  //独立波特率发生器开始计数
 108   3              }
 109   2          else
 110   2              {//如果使用定时器1做波特率发生器
 111   3              TMOD&=0xCF;                                 //清除定时器1设置状态，定时器0不修改
 112   3              TMOD|=0x20;                                 //定时器1使用8位自动重装模式
 113   3              //PCON |= 0x80;                               //串口1波特率加倍
 114   3              //PCON &= 0x7f;                               //串口1波特率不加倍
 115   3              AUXR &= 0xBF;                               //定时器1使用12T模式
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 3   

 116   3              //AUXR|=0x40;                                 //定时器1使用1T模式
 117   3              TH1  = TL1 = 256-Uart1_Brt/12;              //设置自动装入的值
 118   3              ET1  = 0;                                   //关闭定时器1中断
 119   3              TR1  = 1;                                   //TCON|=0x40;定时器1开始计数,TCON&=0xBF;关闭计数
 120   3              }
 121   2          }
 122   1      else
 123   1          {//如果重装值<255,使用1T模式1分频
 124   2          if(Uart1_Tx)
 125   2              {//如果使用独立波特率发生器
 126   3              //PCON |= 0x80;                                 //串口1波特率加倍
 127   3              //PCON &= 0x7f;                                 //串口1波特率不加倍
 128   3              //AUXR &= 0xFB;                                 //独立波特率使用12T模式
 129   3              AUXR |= 0x04;                                 //独立波特率使用1T模式
 130   3              BRT  = 256-Uart1_Brt;                         //独立波特率发生器初值设置
*** ERROR C202 IN LINE 130 OF UART_TEST0.c: 'BRT': undefined identifier
 131   3              AUXR|= 0x10;                                  //独立波特率发生器开始计数
 132   3              }
 133   2          else
 134   2              {//如果使用定时器1做波特率发生器
 135   3              TMOD&=0xCF;                                 //清除定时器1设置状态，定时器0不修改
 136   3              TMOD|=0x20;                                 //定时器1使用8位自动重装模式
 137   3              //PCON |= 0x80;                               //串口1波特率加倍
 138   3              //PCON &= 0x7f;                               //串口1波特率不加倍
 139   3              //AUXR &= 0xBF;                               //定时器1使用12T模式
 140   3              AUXR|=0x40;                                 //定时器1使用1T模式
 141   3              TH1  = TL1 = 256-Uart1_Brt;                 //设置自动装入的值
 142   3              ET1  = 0;                                   //关闭定时器1中断
 143   3              TR1  = 1;                                   //TCON|=0x40;定时器1开始计数,TCON&=0xBF;关闭计数
 144   3              }
 145   2          }
 146   1          ES        = 1;                                  //打开串口中断
 147   1          EA        = 1;                                  //打开总中断
 148   1      }
 149          /*********************************************************
 150          ** 函数名称: void Uart2_Setup(unsigned long Uart2_Baud) 
 151          ** 功能描述: 初始化串口函数
 152          ** 输　  入: unsigned long Uart1_Baud
 153          ** 输　  出: 无
 154          ** 全局变量: 
 155          ** 调用模块: 
 156          ** 备    注:时钟为22118400Hz
 157                      参数1:波特率设置,300;600;1200;2400;4800;9600;19200
 158          **********************************************************/
 159          void Uart2_Setup(unsigned long Uart2_Baud) 
 160          {
 161   1      unsigned int Uart2_Brt;
 162   1      //校验方式设置-------------------------------------------------
 163   1      switch (Uart2_ParitySet)
 164   1          {//判断校验方式
 165   2          case 1:
 166   2              {//9位串口, 奇校验 Uart1_ParitySet=1;   //校验位初值状态标记置1
 167   3              S2CON=0xD8;           //9位波特率可变,允许接收,TB8待发第9位初始置1
 168   3              break;
 169   3              }
 170   2          case 2:
 171   2              {//9位串口, 偶校验 Uart1_ParitySet=2;   //校验位初值状态标记置2
 172   3              S2CON=0xD4;           //9位波特率可变,允许接收,RB8待收第9位初始置1
 173   3              break;
 174   3              }
 175   2          case 3:
 176   2              {//9位串口, 掩码校验 校验值始终为 1 Uart1_ParitySet=3;   //校验位初值状态标记置3
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 4   

 177   3              S2CON|=0xD8;         //9位波特率可变,允许接收,TB8待发第9位初始置1
 178   3              break;
 179   3              }
 180   2          case 4:
 181   2              {//9位串口, 空校验 校验值始终为 0 Uart1_ParitySet=4;   //校验位初值状态标记置4
 182   3              S2CON=0xD4;          //9位波特率可变,允许接收,RB8待收第9位初始置1
 183   3              break;
 184   3              }
 185   2          default:
 186   2              {//8位串口, 无校验 Uart1_ParitySet=0;   //校验位初值状态标记置0
 187   3              S2CON&=0x5F;         //清除第5位,第7位
 188   3              S2CON|=0x50;         //8位波特率可变,允许接收
 189   3              break;
 190   3              }
 191   2          }
 192   1      //波特率设置并开始运行串口-------------------------------------------------
 193   1      //时钟为22118400Hz
 194   1      Uart2_Brt=FOSC/32/Uart2_Baud;
 195   1      if(Uart2_Brt>255)
 196   1          {//如果重装值>255,使用12T模式12分频
 197   2              //PCON |= 0x80;                                 //串口1波特率加倍
 198   2              //PCON &= 0x7f;                                 //串口1波特率不加倍
 199   2              AUXR &= 0xFB;                                 //独立波特率使用12T模式
 200   2              //AUXR |= 0x04;                                 //独立波特率使用1T模式
 201   2              BRT = 256-Uart2_Brt/12;                       //独立波特率发生器初值设置
*** ERROR C202 IN LINE 201 OF UART_TEST0.c: 'BRT': undefined identifier
 202   2          }
 203   1      else
 204   1          {//如果重装值<255,使用1T模式1分频
 205   2              //PCON |= 0x80;                                 //串口1波特率加倍
 206   2              //PCON &= 0x7f;                                 //串口1波特率不加倍
 207   2              //AUXR &= 0xFB;                                 //独立波特率使用12T模式
 208   2              AUXR |= 0x04;                                 //独立波特率使用1T模式
 209   2              BRT  = 256-Uart2_Brt;                         //独立波特率发生器初值设置
*** ERROR C202 IN LINE 209 OF UART_TEST0.c: 'BRT': undefined identifier
 210   2          }
 211   1          AUXR|= 0x10;                                  //独立波特率发生器开始计数
 212   1      IE2|=0x01;                                    ////打开串口2中断
 213   1          EA   = 1;                                     //打开总中断
 214   1      }
 215          //=======================================================================================
 216          /**********************************************************
 217          串口1中断服务函数
 218          **********************************************************/
 219          void Uart1_Isr() interrupt 4 using 1
 220          {// UART 中断服务函数
 221   1      EA=0; //关总中断
 222   1      if (RI)
 223   1      {//如果 UART 接收产生中断
 224   2          RI = 0;                                           //清除 UART 接收中断标记
 225   2          ACC= SBUF;                                        //接收缓冲区数据写入累加器A
 226   2          Uart1_Parity = P;                                 //保存校验值到Uart1_Parity
 227   2          Uart1_Parity_out=0;                               //清除允许写入标记，为下面判断准备
 228   2          switch(Uart1_ParitySet)
 229   2          {//根据校验要求判断
 230   3              case 1:
 231   3              {//要求奇校验
 232   4              Uart1_Parity_out=Uart1_Parity^RB8;    //如果检验结果和接收结果不符合则成立，允许写入
 233   4              break;
 234   4              }
 235   3              case 2:
 236   3              {//要求偶校验
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 5   

 237   4              Uart1_Parity_out=~(Uart1_Parity^RB8); //如果检验结果和接收结果符合则成立，允许写入
 238   4              break;
 239   4              }
 240   3              case 3:
 241   3              {//要求常1校验
 242   4              Uart1_Parity_out=RB8;                 //如果接收结果为1则成立，允许写入
 243   4              break;
 244   4              }
 245   3              case 4:
 246   3              {//要求常0校验
 247   4              Uart1_Parity_out=~RB8;                //如果接收结果为0则成立，允许写入
 248   4              break;
 249   4              }
 250   3              default:
 251   3              {//要求无校验
 252   4              Uart1_Parity_out=1;                  //如果无校验，允许写入
 253   4              break;
 254   4              }
 255   3          }
 256   2          if(Uart1_Parity_out)
 257   2          {//如果允许写入
 258   3              Uart1_Data[Uart1_String_P]= SBUF;              //接收缓冲区数据顺序写入串口接收字串
 259   3              Uart1_String_P++;                              //串口接收字串指针累加
 260   3              //↓如果串口接收字串指针在大于最大接收缓冲区字符数量,串口接收字串指针归零
 261   3              if(Uart1_String_P >= Uart1_MaxString) 
 262   3              {//如果接受字串指针越界
 263   4                  Uart1_String_P=0;                          //接受字串指针归零
 264   4              }
 265   3          }
 266   2      }
 267   1      if (TI)
 268   1      {//如果 UART 发送产生中断
 269   2          TI   = 0;                  //清除 UART 发送中断标记
 270   2          Uart1_busy = 0;            //发送完成，清除正在发送标记
 271   2      }
 272   1      EA=1;                          //开总中断
 273   1      }
 274          //=======================================================================================
 275          /**********************************************************
 276          串口2中断服务函数
 277          **********************************************************/
 278          void Uart2_Isr() interrupt 8 using 1
 279          {// UART 中断服务函数
 280   1      EA=0; //关总中断
 281   1      if (S2CON&0x01)
 282   1      {//如果 UART 接收产生中断
 283   2          S2CON &= 0xFE;                                     //清除 UART 接收中断标记
 284   2          ACC= S2BUF;                                        //接收缓冲区数据写入累加器A
 285   2          Uart2_Parity = P;                                  //保存校验值到Uart1_Parity
 286   2          Uart2_Parity_out=0;                                //清除允许写入标记，为下面判断准备
 287   2          switch(Uart2_ParitySet)
 288   2          {//根据校验要求判断
 289   3              case 1:
 290   3              {//要求奇校验
 291   4              Uart2_Parity_out=Uart2_Parity^(S2CON&0x04);    //如果检验结果和接收结果不符合则成立，允许写入 (S2C
             -ON&0x04)==S2RB8
 292   4              break;
 293   4              }
 294   3              case 2:
 295   3              {//要求偶校验
 296   4              Uart2_Parity_out=~(Uart2_Parity^(S2CON&0x04)); //如果检验结果和接收结果符合则成立，允许写入
 297   4              break;
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 6   

 298   4              }
 299   3              case 3:
 300   3              {//要求常1校验
 301   4              Uart2_Parity_out=(S2CON&0x04);                 //如果接收结果为1则成立，允许写入
 302   4              break;
 303   4              }
 304   3              case 4:
 305   3              {//要求常0校验
 306   4              Uart2_Parity_out=~(S2CON&0x04);                //如果接收结果为0则成立，允许写入
 307   4              break;
 308   4              }
 309   3              default:
 310   3              {//要求无校验
 311   4              Uart2_Parity_out=1;                  //如果无校验，允许写入
 312   4              break;
 313   4              }
 314   3          }
 315   2          if(Uart2_Parity_out)
 316   2          {//如果允许写入
 317   3              Uart2_Data[Uart2_String_P]= S2BUF;              //接收缓冲区数据顺序写入串口接收字串
 318   3              Uart2_String_P++;                              //串口接收字串指针累加
 319   3              //↓如果串口接收字串指针在大于最大接收缓冲区字符数量,串口接收字串指针归零
 320   3              if(Uart2_String_P >= Uart2_MaxString) 
 321   3              {//如果接受字串指针越界
 322   4                  Uart2_String_P=0;                          //接受字串指针归零
 323   4              }
 324   3          }
 325   2      }
 326   1      if (S2CON&0x02)
 327   1      {//如果 UART 发送产生中断
 328   2          S2CON &= 0xFD;                  //清除 UART 发送中断标记
 329   2          Uart2_busy = 0;            //发送完成，清除正在发送标记
 330   2      }
 331   1      EA=1;                          //开总中断
 332   1      }
 333          
 334          //=======================================================================================
 335          /**********************************************************
 336          ** 函数名称: void Uart1_SendData(unsigned char Uart1_dat)
 337          ** 功能描述: UART1 单个字符发送函数
 338          ** 输　  入: unsigned char Uart1_dat
 339          ** 输　  出: 无
 340          ** 全局变量: 
 341          ** 调用模块: 
 342          ** 备    注:参数1:待发送的单个字符
 343          **********************************************************/
 344          void Uart1_SendData(unsigned char Uart1_dat)
 345          {//UART 发送字节函数
 346   1          while (Uart1_busy);       //循环等待正在发送标记被清空
 347   1          ACC = Uart1_dat;                //被发送数据送累加器A,准备求奇偶校验位 P
 348   1          TB8 = P;                  //写奇偶校验标记
 349   1          switch(Uart1_ParitySet)
 350   1          {//根据校验要求判断
 351   2              case 1:
 352   2              {//要求奇校验
 353   3                  TB8=~TB8;        //翻转TB8的值
 354   3                  break;
 355   3              }
 356   2              /*偶校验，TB8不变
 357   2              case 2:
 358   2              {//要求偶校验
 359   2                  TB8=TB8;            //TB8不变
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 7   

 360   2                  break;
 361   2              }
 362   2              */
 363   2              case 3:
 364   2              {//要求常1校验
 365   3                  TB8=1;            //TB8恒等于1
 366   3                  break;
 367   3              }
 368   2              case 4:
 369   2              {//要求常0校验
 370   3                  TB8=0;            //TB8恒等于0
 371   3                  break;
 372   3              }
 373   2              default:
 374   2              {//要求无校验
 375   3              break;
 376   3              }
 377   2          }
 378   1          Uart1_busy = 1;          //正在发送标记置 1
 379   1          SBUF = ACC;              //累加器 A 中的数据送发送缓冲区发送
 380   1      }
 381          //=======================================================================================
 382          /**********************************************************
 383          ** 函数名称: void Uart2_SendData(unsigned char Uart2_dat)
 384          ** 功能描述: UART2 单个字符发送函数
 385          ** 输　  入: unsigned char Uart2_dat
 386          ** 输　  出: 无
 387          ** 全局变量: 
 388          ** 调用模块: 
 389          ** 备    注:参数1:待发送的单个字符
 390          **********************************************************/
 391          void Uart2_SendData(unsigned char Uart2_dat)
 392          {//UART 发送字节函数
 393   1          while (Uart2_busy);       //循环等待正在发送标记被清空
 394   1          ACC = Uart2_dat;                //被发送数据送累加器A,准备求奇偶校验位 P
 395   1          TB8 = P;                  //写奇偶校验标记
 396   1          switch(Uart2_ParitySet)
 397   1          {//根据校验要求判断
 398   2              case 1:
 399   2              {//要求奇校验
 400   3                  S2CON^=0x08;        //翻转S2TB8的值
 401   3                  break;
 402   3              }
 403   2              /*偶校验，S2TB8不变
 404   2              case 2:
 405   2              {//要求偶校验
 406   2                  S2TB8=1;            //S2TB8不变
 407   2                  break;
 408   2              }
 409   2              */
 410   2              case 3:
 411   2              {//要求常1校验
 412   3                  S2CON|=0x08;            //S2TB8恒等于1
 413   3                  break;
 414   3              }
 415   2              case 4:
 416   2              {//要求常0校验
 417   3                  S2CON&=0xF7;            //TB8恒等于0
 418   3                  break;
 419   3              }
 420   2              default:
 421   2              {//要求无校验
C51 COMPILER V9.54   UART_TEST0                                                            12/06/2015 09:03:35 PAGE 8   

 422   3              break;
 423   3              }
 424   2          }
 425   1          Uart2_busy = 1;          //正在发送标记置 1
 426   1          S2BUF = ACC;              //累加器 A 中的数据送发送缓冲区发送
 427   1      }
 428          //=======================================================================================
 429          /**********************************************************
 430          ** 函数名称: void Uart1_SendString(char *s)
 431          ** 功能描述: UART1 按字符串发送函数
 432          ** 输　  入: char *s
 433          ** 输　  出: 无
 434          ** 全局变量: 
 435          ** 调用模块: 
 436          ** 备    注:参数1:待发送的字符串
 437          **********************************************************/
 438          void Uart1_SendString(char *s)
 439          {//UART 按字符串发送
 440   1          while (*s)
 441   1          {
 442   2              Uart1_SendData(*s++);   //将待发字符串依次使用SendData函数按字节发送
 443   2          }
 444   1      }
 445          //=======================================================================================
 446          /**********************************************************
 447          ** 函数名称: void Uart2_SendString(char *s)
 448          ** 功能描述: UART2 按字符串发送函数
 449          ** 输　  入: char *s
 450          ** 输　  出: 无
 451          ** 全局变量: 
 452          ** 调用模块: 
 453          ** 备    注:参数1:待发送的字符串
 454          **********************************************************/
 455          void Uart2_SendString(char *s)
 456          {//UART 按字符串发送
 457   1          while (*s)
 458   1          {
 459   2              Uart2_SendData(*s++);   //将待发字符串依次使用SendData函数按字节发送
 460   2          }
 461   1      }
 462          //=======================================================================================
 463          /*常用串口设置开关===============================副录===================================
 464          AUXR |= 0x01;  //串口1选择独立波特率发生器
 465          AUXR &= 0xFE;  //串口1选择定时器1做波特率发生器
 466          AUXR |= 0x40;  //定时器1使用1T模式
 467          AUXR &= 0xBF;  //定时器1使用12T模式
 468          AUXR |= 0x04;  //独立波特率使用1T模式
 469          AUXR &= 0xFB;  //独立波特率使用12T模式
 470          AUXR |= 0x10;  //打开独立波特率发生器
 471          AUXR &= 0xEF;  //关闭独立波特率发生器
 472          PCON |= 0x80;  //串口1波特率加倍
 473          PCON &= 0x7f;  //串口1波特率不加倍
 474          AUXR |= 0x08;   //串口2波特率加倍
 475          AUXR &= 0xf7;   //串口2波特率不加倍
 476          =======================================================================================*/

C51 COMPILATION COMPLETE.  0 WARNING(S),  4 ERROR(S)

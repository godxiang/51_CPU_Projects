C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          
   3          
   4          void main(void)
   5            {
   6   1      
   7   1          init_Uart();
   8   1          IO_Init();
   9   1          
  10   1          while(1){
  11   2            if(Uart3HaveData){
  12   3            Delay200ms();                       //等待串口接收数据完毕
  13   3            UART3_Proccess();                   //串口数据处理
  14   3            CommonMessProce();                  //通用消息处理函数
  15   3            }
  16   2          };    
  17   1      }
  18          /*****************************************/
  19          /* 串口1、4初始化                          */
  20          /* 程序功能：串口1、4初始化                */
  21          /* 入口参数:无                           */
  22          /* 出口参数:无                           */
  23          /*****************************************/
  24          void init_Uart()
  25            {
  26   1          P_SW2 &= ~S4_S0;            //S4_S0=0 (P0.2/RxD4, P0.3/TxD4)
  27   1          ACC = P_SW1;
  28   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
  29   1          P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
  30   1          SCON = 0x50;                //1010000
  31   1          S3CON = 0x10;
  32   1          S4CON = 0x10;               //10000
  33   1          T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
  34   1          T2H = (65536 - (FOSC/4/BAUD))>>8;
  35   1          AUXR = 0x14;                //T2为1T模式, 并启动定时器2 10100
  36   1          AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
  37   1          ES = 1;                     //使能串口1中断
  38   1          IE2 = 0x18;                 //使能串口3,4中断
  39   1          EA = 1;
  40   1      }
  41            
  42          
  43          /*----------------------------
  44          UART3 中断服务程序
  45          -----------------------------*/
  46          void Uart3_ISR() interrupt 17 using 1
  47          {
  48   1        EA =0;
  49   1          if (S3CON & 0x01 )
  50   1          {
  51   2            if(Re_Cnt < 100)
  52   2              S3_Re_Buffer[Re_Cnt++] = S3BUF;
  53   2            Uart3HaveData = 1;        //标志串口3有数据进来
  54   2              S3CON &= ~0x01;         //清除S3RI位  
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 2   

  55   2          }
  56   1          if (S3CON & 0x02)
  57   1          {
  58   2              S3CON &= ~0x02;         //清除S3TI位
  59   2              Uart3busy = 0;               //清忙标志
  60   2          }
  61   1          EA = 1;
  62   1      }
  63          
  64          
  65          /*----------------------------
  66          UART4 中断服务程序
  67          -----------------------------*/
  68          void Uart4_ISR() interrupt 18 using 1
  69          {
  70   1        unsigned char dat;
  71   1        EA=0;
  72   1            if (S4CON & S4RI)
  73   1          {
  74   2            dat = S4BUF;
  75   2            if(Rece_Cnt < 1295)                                 
  76   2            re_data_buffer[Rece_Cnt++] = dat;
  77   2              S4CON &= ~S4RI;                                               //串口接收中断标记需软件清零
  78   2          }
  79   1              
  80   1          
  81   1          if (S4CON & S4TI)
  82   1          {
  83   2            S4CON&= ~S4TI;
  84   2            Uart4busy=0;
  85   2          }
  86   1        EA=1;
  87   1      }
  88          /***********************************************
  89          *函数名称：Uart4_Process
  90          *功    能：串口命令处理函数
  91          *入口参数：无
  92          *返 回 值：无 
  93          *备    注：无
  94          ************************************************/
  95          void Uart4_Process(void)  
  96          {
  97   1        unsigned int i,j;
  98   1        length = Hex2Int (re_data_buffer[5])*256 + Hex2Int (re_data_buffer[6]);//十六进制转换为10进制
  99   1        if(length == 4 &&re_data_buffer[9] == 0x80 && re_data_buffer[10] == 0x84){
 100   2        OpCart_FindCart_State = 0;
 101   2        }
 102   1        if(length == 4 &&re_data_buffer[9] == 0x81 && re_data_buffer[10] == 0x85){
 103   2        OpCart_SelectCart_State = 0;
 104   2        }
 105   1        if(length == 4 &&re_data_buffer[9] == 0x41 && re_data_buffer[10] == 0x45){
 106   2        OpCart_ReadCart_State = 0;
 107   2        }
 108   1        if(length == 8)
 109   1          OpCart_FindCart_State = 1;
 110   1        if(length == 12)
 111   1          OpCart_SelectCart_State = 1;
 112   1        if(length == 1288){
 113   2          OpCart_ReadCart_State = 1;
 114   2          for(j=0,i = 136;j<18,i < 171;i++,j++){                                    //取身份证号码                                                                    
             -  
 115   3            Id_Number[j] = re_data_buffer[i];
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 3   

 116   3            i++;                                                                    //隔一位取一位
 117   3          } 
 118   2        }
 119   1        Rece_Cnt = 0;                                                               //接收计数器归零
 120   1      }
 121          /*----------------------------------------
 122          串口3处理上位机信息（从WIFI模块）函数
 123          ----------------------------------------*/
 124          void UART3_Proccess(void){
 125   1        bit Header_State;
 126   1        unsigned char i,j = 0;
 127   1        unsigned char CS = 0x00;
 128   1          if(S3_Re_Buffer[0] == 0x55 && S3_Re_Buffer[1] == 0xaa)
 129   1            Header_State = 1;
 130   1          else
 131   1            Header_State = 0;
 132   1          if(Header_State == 1){                                                //头没有出错
 133   2          Re_length = Hex2Int (S3_Re_Buffer[2])*256 + Hex2Int (S3_Re_Buffer[3]);//获得data的长度，以便计算校验码CS
 134   2          for(i=4;i<10;i++){
 135   3              if(LocalHostNum[i] == S3_Re_Buffer[i])                            //判断是否是本机编号
 136   3                j++;
 137   3            
 138   3          }
 139   2            if(j==6){                                                           //是本机编号
 140   3              for (j = 13;j<Re_length + 13;j++){                                //计算校验码CS
 141   4                CS+=S3_Re_Buffer[j];
 142   4              }
 143   3              if(CS == S3_Re_Buffer[13+Re_length])                              //校验码CS是否出错 不出错则进行数据解析
 144   3              {
 145   4                Uart3SendString("CS Passed!\n");
 146   4                //Uart3SendData(CS);
 147   4                if(S3_Re_Buffer[14+Re_length] == 0x16 && S3_Re_Buffer[15+Re_length] == 0x00){           //检查尾巴0x16
 148   5                for(j=0;j<6;j++)
 149   5                    {
 150   6                    if(MessageType[j][0] == S3_Re_Buffer[11] && MessageType[j][1] == S3_Re_Buffer[12]) //这里确定MessTy
             -pe 
 151   6                    MessType = j;
 152   6                  }
 153   5                }
 154   4                else 
 155   4                  MessType = 0xff;                                                //如果输入过长，提示输入错误，MessType为默认
 156   4              }
 157   3              else
 158   3                Uart3SendString("CS Error!\n");
 159   3            }
 160   2            else
 161   2              Uart3SendString("not localhost number!\n");
 162   2          }
 163   1          Uart3HaveData = 0;                                                      //数据处理完置串口3数据标记为0，等待下一次数据进入
 164   1          Re_Cnt = 0;                                                             //计数器归零
 165   1          if(MessType != 0x03){                                                   //存身份证数据需要用到接收区数据
 166   2            for(i=0;i<100;i++)
 167   2          S3_Re_Buffer[i] = 0x00;                                                 //接收取初始化为0x00
 168   2          }
 169   1        }
 170          /***********************************************
 171          *函数名称：CommonMessProce
 172          *功    能：通用消息处理函数函数
 173          *入口参数：无
 174          *返 回 值：无 
 175          *备    注：根据消息类型MessType值做出相应动作
 176          ************************************************/
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 4   

 177          
 178          void CommonMessProce(void){
 179   1        unsigned char i,j;
 180   1        
 181   1        switch (MessType){
 182   2          case 0x00 :
 183   2            Uart3SendString("Heart packet!\n");
 184   2            break;
 185   2          case 0x01 :
 186   2            Uart3SendString("Realoading!\n");
 187   2            break;
 188   2          case 0x02 :                                                               //开闸
 189   2            Uart3SendString("Open The Door!\n");
 190   2            P43 = 0;
 191   2            P44 = 0;
 192   2            Delay2000ms();
 193   2            P43 = 1;
 194   2            P44 = 1;
 195   2            break;
 196   2          case 0x03 :                                                               //下载业主身份证信息
 197   2          for(i=2,j=13;i<20,j<31;i++,j++)
 198   2            IdData[i] = S3_Re_Buffer[j];                                            //整理数据，准备往Flash中存
 199   2            for (i=0;i<100;i++)                                                     //存完将接收数组置零
 200   2            S3_Re_Buffer[i] = 0x00;
 201   2            sFLASH_EraseSector(FLASH_SectorToErase);                                //删除一个扇区
 202   2            sFLASH_ReadBuffer(TotalNumData,FLASH_ReadAddress,2);                   //上电稳定以后先读取Flash中储存数据的个
             -数
 203   2            Save_IDNum_ToFlash();
 204   2            Uart3SendString("Save Id Number Success!\n");
 205   2            break;
 206   2          case 0x04 :                                                             //身份信息验证
 207   2            Uart3SendString("Please Scan the ID Cart!\n");
 208   2            Op_IdCard();                                                          //身份证信息扫描录入
 209   2            if(Compare_Id_NumberInfo()){                                          //开始对比数据
 210   3              Uart3SendString("ID Number Verification Pass!Open The Door!\n");
 211   3              P43 = 0;                                                            //开闸
 212   3              P44 = 0;
 213   3              Delay2000ms();
 214   3              P43 = 1;
 215   3              P44 = 1;
 216   3            }
 217   2            else
 218   2              Uart3SendString("ID Number Error!\n");
 219   2            break;
 220   2          case 0x05 :                                                               //发送心跳包
 221   2            for(i=0;i<16;i++){
 222   3            Uart3SendData(HeartBreak[i]);
 223   3            }
 224   2          default :
 225   2            Uart3SendString("Please Input right command!\n");
 226   2          }
 227   1        MessType = 0xff;                                                          //MessType 消息处理完后，恢复到默认状态。
 228   1      }
 229          /***********************************************
 230          *函数名称：Compare_Id_NumberInfo
 231          *功    能：身份证信息验证
 232          *入口参数：无
 233          *返 回 值：无 
 234          *备    注：无
 235          ************************************************/
 236          bit Compare_Id_NumberInfo(void){
 237   1        unsigned int Cnt,Cnt0,ID;
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 5   

 238   1        ID=sFLASH_ReadID();             //读取W25Q64的器件ID号                                    
 239   1          if(ID!=sFLASH_W25Q64_ID)        //如果ID号不同
 240   1          {
 241   2            Uart3SendString("ID ERROR!");
 242   2            while(1); 
 243   2          }
 244   1      
 245   1        //Uart1SendString("Start Read Write Test!\n");
 246   1        //Uart1SendString("Erase!\n");
 247   1        //Delay_ms(100);
 248   1        //写之前需先擦除，擦除一个扇区
 249   1        //sFLASH_EraseSector(FLASH_SectorToErase);
 250   1        //Uart1SendString("Write!\n");
 251   1        //Delay_ms(300);
 252   1        //写入一页的数据
 253   1        //sFLASH_WritePage(Id_Number,FLASH_WriteAddress,18);
 254   1        //Uart1SendString("Read!\n");
 255   1        Delay_ms(300);
 256   1        //将该页的数据读
 257   1        sFLASH_ReadBuffer(spi_re_data_buffer,FLASH_Address,20);
 258   1        //比较写入和读取的数据是否一致
 259   1        for(Cnt0=0,Cnt=2;Cnt<20,Cnt0<18;Cnt++,Cnt0++) 
 260   1        {
 261   2          //Uart1SendData(spi_re_data_buffer[Cnt]);
 262   2          //如果有数据不同
 263   2          if(spi_re_data_buffer[Cnt]!=Id_Number[Cnt0])
 264   2          {     
 265   3            return 0;     
 266   3          } 
 267   2        } 
 268   1        if(Cnt == 0x0014){                              //数据没有错
 269   2          return 1;
 270   2        }
 271   1        return 0;
 272   1      }
 273          
 274          
 275          /***********************************************
 276          *函数名称：Save_IDNum_ToFlash
 277          *功    能：将上位机发来的数据有序地放进Flash储存器中
 278          *入口参数1：Data 20位（2位序号  18位身份证号）
 279          *返 回 值：无 
 280          *备    注：无
 281          ************************************************/
 282          void Save_IDNum_ToFlash(void){
 283   1        
 284   1        TotalNumData[0] = (unsigned char)(TotalNum>>8);                       //TotalNum的高8位
 285   1        TotalNumData[1] = (unsigned char)TotalNum;                            //TotalNum的低8位
 286   1        sFLASH_WritePage(TotalNumData,FLASH_WriteAddress,2);                  //保存一下数据的个数  以便下次写操作追加  下
             -次写操作先读取这个数 然后定位写的地址
 287   1        TotalNum = Hex2Int (TotalNumData[0])*256 + Hex2Int (TotalNumData[1]); //十六进制转换为10进制
 288   1        FLASH_Address = (unsigned long int)(TotalNum*20);
 289   1        FLASH_Address+=2;                                                     //指针右移2个字节
 290   1        sFLASH_WritePage(IdData,FLASH_Address,20);
 291   1        TotalNum++;
 292   1      }
 293          /***********************************************
 294          *函数名称：Op_IdCard
 295          *功    能：身份证模块操作函数
 296          *入口参数：无
 297          *返 回 值：无 
 298          *备    注：无
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 6   

 299          ************************************************/
 300          void Op_IdCard(void){
 301   1        unsigned int n,Cnt;
 302   1        bit flag = 0;
 303   1        while(!flag){                                               //不断循环等待放卡
 304   2          while(!OpCart_FindCart_State){                        //一直等待寻卡成功
 305   3            for (n=0;n<10;n++){
 306   4                Uart4SendData(FIND_CARD[n]);  
 307   4              }
 308   3                  //Uart4_Process();
 309   3              Delay200ms();     //等待接收数据
 310   3              Uart4_Process();
 311   3            }
 312   2        if(OpCart_FindCart_State == 1){
 313   3          Cnt = 0;
 314   3          while(!OpCart_SelectCart_State && Cnt < 10){                      //一直等待选卡成功,最多重试10次 避免寻卡成功后移
             -除了卡 而导致死循环
 315   4            for (n=0;n<10;n++){
 316   5              Uart4SendData(SELECT_CARD[n]);  
 317   5            }
 318   4                //Uart4_Process();  
 319   4            Delay200ms();       //等待接收数据
 320   4            Uart4_Process();
 321   4            Cnt++;
 322   4          }
 323   3        }
 324   2        if(OpCart_FindCart_State == 1 && OpCart_SelectCart_State == 1){
 325   3          Cnt = 0;
 326   3          while(!OpCart_ReadCart_State && Cnt < 3){                       //一直等待读卡成功
 327   4            for (n=0;n<10;n++){
 328   5              Uart4SendData(READ_CARD[n]);  
 329   5            }
 330   4            Delay2000ms();                                      //等待接收数据，这里模块返回数据延迟高需要等待的时间长一些。
 331   4            Uart4_Process();
 332   4            Cnt++;
 333   4          }
 334   3        if(Cnt == 1){
 335   4        Uart3SendString("Id Cart Read Success!\n");
 336   4        flag = 1;                                               //读卡成功置标志位Flag为0
 337   4        }
 338   3        }
 339   2          OpCart_FindCart_State = 0;                            //读取一张卡后重新初始化
 340   2          OpCart_SelectCart_State = 0;
 341   2          OpCart_ReadCart_State = 0;
 342   2        }
 343   1      }
 344          /*----------------------------
 345          串口4发送数据
 346          ----------------------------*/
 347          void Uart4SendData(unsigned char Udat)
 348          {
 349   1        while(Uart4busy);
 350   1        ACC = Udat;
 351   1        Uart4busy=1;
 352   1        S4BUF = ACC;
 353   1      }
 354          
 355          
 356          void Uart4SendString(char *s)
 357          {
 358   1          while (*s)                 
 359   1          {
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 7   

 360   2               Uart4SendData(*s++);         
 361   2          }
 362   1      }
 363          
 364          /*----------------------------
 365          UART 中断服务程序
 366          -----------------------------*/
 367          void Uart1_ISR() interrupt 4 using 1
 368          {
 369   1        EA=0;
 370   1          if (RI)
 371   1          {
 372   2              RI = 0;                 //清除RI位
 373   2          }
 374   1          if (TI)
 375   1          {
 376   2              TI = 0;                 //清除TI位
 377   2              Uart1busy = 0;               //清忙标志
 378   2          }
 379   1        EA=1;
 380   1      }
 381          
 382          /*----------------------------
 383          发送串口数据
 384          ----------------------------*/
 385          void Uart1SendData(unsigned char dat)
 386          {
 387   1          while (Uart1busy);               //等待前面的数据发送完成
 388   1          Uart1busy = 1;
 389   1          SBUF = dat;                 //写数据到UART数据寄存器
 390   1      }
 391          
 392          /*----------------------------
 393          发送字符串
 394          ----------------------------*/
 395          void Uart1SendString(char *s)
 396          {
 397   1          while (*s)                  //检测字符串结束标志
 398   1          {
 399   2              Uart1SendData(*s++);         //发送当前字符
 400   2          }
 401   1      }
 402          /*----------------------------
 403          串口3发送串口数据
 404          ----------------------------*/
 405          
 406          void Uart3SendData( unsigned char dat )
 407          {
 408   1          while (Uart3busy);          
 409   1          Uart3busy = 1;
 410   1          S3BUF = dat;               
 411   1      }
 412          
 413          /*----------------------------
 414          串口3发送字符串
 415          ----------------------------*/
 416          
 417          void Uart3SendString(char *s)
 418          {
 419   1          while (*s)               
 420   1          {
 421   2              Uart3SendData(*s++);        
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 8   

 422   2          }
 423   1      }
 424          
 425          
 426          /***********************************************
 427          函数名称：IO_Init
 428          功    能：单片机IO端口模式初始化
 429          入口参数：无
 430          返 回 值：无  
 431          备    注：STC15W4K32S4系列A版单片机部分端口复位后
 432                    不是准双向口,需要设置才能正常使用
 433          ************************************************/
 434          void IO_Init(void)
 435          {
 436   1      
 437   1        //将P04 P05 P06 P07设置为开漏口
 438   1        //因为单片机为5V端口，W25Q64为3.3V端口，为了实现电平匹配
 439   1        //将单片机设置为开漏结构，由外部上拉到3.3V。
 440   1         P4M0 = 0;
 441   1         P4M1 = 0;                                              //继电器端口初始化
 442   1         P0M1 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;  
 443   1         P0M0 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;
 444   1        //分析
 445   1        //  1<<0等价于0x01 即 0000 0001
 446   1        //  1<<1等价于0x02 即 0000 0010
 447   1        //  1<<2等价于0x04 即 0000 0100
 448   1        //  1<<3等价于0x08 即 0000 1000
 449   1        //  以此类推1<<n 即第n位为1，其余位是0
 450   1      
 451   1        //  x |=(1<<n)  即对x执行按位取或 
 452   1        //  即x中的第n位置为1，不改变其他位状态  
 453   1        
 454   1        //  y &=~(1<<n)  即将1<<n按位取反，然后对y按位取与 
 455   1        //  即y中的第n位置为0，不改变其他位状态  
 456   1         P2M0 = 0x30;       //00110000
 457   1         P2M1 = 0xc0;       //11000000      设定P2.0 P2.1 P2.2 P2.3 为高阻输入 P2.4 P2.5为输出  P2.6 P2.7为高阻输入
 458   1         P1M0 = 0x20;       //00000100
 459   1         P1M1 = 0x10;       //00001000      设定P1.2为输出,设定P1.3为高阻输入
 460   1         
 461   1         
 462   1        //P10 P14复位后为强推挽输出、强上拉，
 463   1        //防止不当操作导致端口损坏，初始化为准双向口 
 464   1        //将P10 P14设置为准双向口
 465   1        //P1M1 &=~( (1<<0) | (1<<4) );  
 466   1        //P1M0 &=~( (1<<0) | (1<<4) );
 467   1        
 468   1      }                             
 469          /***************************************************************/
 470          /*函数名称：void Sent_Byte(unsigned char Data0)                */
 471          /*函数功能：发送一个字节的低4位                                */
 472          /*入口参数：无                                                 */
 473          /*出口参数：无                                                 */
 474          /*发送数据流程① 一方单片机检查8位端口状态信号CHKREQ ，以判断对方是否已提 出发送数据的申请。
 475                        ② 如果对方提出申请则等待，否则提出发送数据申请，并置REQ有效。 
 476                  ③ 再次检查8位端口状态信号CHKREQ判断对方是否提出发送数据的申请。
 477                  ④ 如果对方提出申请则发生冲突，清楚REQ并延时，然后执行第一步。
 478                  ⑤ 将数据送8位端口，再设定STB有效, 使对方进入中断以便取走数据。
 479                  ⑥ 检查CHK，等待对方单片机取走数据。
 480                  ⑦ 检查数据是否发 送完，如果没有则继续执行步骤5进行发送。
 481                  ⑧ 撤销REQ信号，释放8位端口。
 482                  ⑨ 数据发送 完毕退出流程。
 483          数据接收流程：①进入中断服务流程。
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 9   

 484                        ②从8位端口读取数据。
 485                  ③设置ACK信号有 效，表示数据已成功读取。
 486                  ④退出中断服务流程。
 487          /*           P2>----------------------P2                     */
 488          /*           STB>---------------------INT                    */
 489          /*           REQ>---------------------CHKREQ                 */
 490          /*           INT<---------------------STB                    */
 491          /*           CHKREQ<---------------------REQ                 */
 492          /*           ACK--------------------->CHKACK               */
 493          /*           CHKACK<---------------------ACK               */
 494          /*************************************************************/
 495          unsigned char  Sent_Byte(unsigned char Data0)/*发送一个字节的低4位*/
 496            {/*首先检测当前的位总线是否忙*/
 497   1        if((!Transmit_U2REQ)&&(Transmit_U2BusACK))/*检查U2是否提出发送数据申请，有申请则等待*/
 498   1         {/*U2等待*/
 499   2          Transmit_U1REQ=1;/*提出申请*/
 500   2        if(!Transmit_U2REQ)
 501   2         {   
 502   3           if((Data0&BIT0)==BIT0) {
 503   4         Transmit_DATA0=Transmit_DATA0|BIT0;
 504   4         }
 505   3             else{Transmit_DATA0=Transmit_DATA0&(~BIT0);
 506   4             }
 507   3             if((Data0&BIT1)==BIT1) {
 508   4             Transmit_DATA1=Transmit_DATA1|BIT1;
 509   4             }
 510   3             else{Transmit_DATA1=Transmit_DATA1&(~(BIT1>>1));
 511   4             }
 512   3               if((Data0&BIT2)==BIT2) {
 513   4               Transmit_DATA2=Transmit_DATA2|BIT2;}
 514   3               else{Transmit_DATA2=Transmit_DATA2&(~(BIT2>>2));
 515   4               }
 516   3               if((Data0&BIT3)==BIT3) {
 517   4               Transmit_DATA3=Transmit_DATA3|BIT3;}
 518   3               else{Transmit_DATA3=Transmit_DATA3&(~(BIT3>>3));
 519   4               }
 520   3             Transmit_U1STB=1;/*提出中断申请*/
 521   3           while(!Transmit_U2BusACK);/*等待退出*/
 522   3           Transmit_U1REQ=0;
 523   3           Transmit_U1STB=0;
 524   3           return(0);
 525   3          }
 526   2        else 
 527   2         {Transmit_U1REQ=0;return(1);}
 528   2          }
 529   1        else
 530   1         {return(1);}/*U2忙*/
 531   1         }
 532          /***************************************************************/
 533          /*函数名称：unsigned char Read_Byte(void)                      */
 534          /*函数功能：接收一个字节的低4位                                */
 535          /*入口参数：无                                                 */
 536          /*出口参数：无                                                 */
 537          /***************************************************************/
 538          unsigned char Read_Byte(void)/*接收一个字节的低4位*/
 539            { unsigned char Read_Byte_data=0;
 540   1          if(Transmit_U2STB)/*U2STB=1,读取一个数据*/                    
 541   1           { if(Transmit_DATA0) {Read_Byte_data=Read_Byte_data|BIT0;}
 542   2           if(Transmit_DATA1) {Read_Byte_data=Read_Byte_data|BIT1;}
 543   2           if(Transmit_DATA2) {Read_Byte_data=Read_Byte_data|BIT2;}
 544   2           if(Transmit_DATA3) {Read_Byte_data=Read_Byte_data|BIT3;}
 545   2           Transmit_U2BusACK=1;/*发送数据读取完成相应信号*/
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 10  

 546   2           delay_10us();
 547   2           Transmit_U2BusACK=0;/*发送数据读取完成相应信号*/
 548   2           return(Read_Byte_data);
 549   2          } 
 550   1         else
 551   1          {return(0);}  
 552   1         }
 553            
 554          void delay_10us(void)
 555            { unsigned char i=0,j=0;
 556   1          for(i=0;i<255;i++)
 557   1          for(j=0;j<255;j++)
 558   1           {_nop_();}
 559   1         }
 560          
 561          
 562          
 563          void Delay1000ms()    //@22.1184MHz
 564          {
 565   1        unsigned char i, j, k;
 566   1      
 567   1        _nop_();
 568   1        _nop_();
 569   1        i = 85;
 570   1        j = 12;
 571   1        k = 155;
 572   1        do
 573   1        {
 574   2          do
 575   2          {
 576   3            while (--k);
 577   3          } while (--j);
 578   2        } while (--i);
 579   1      }
 580          void Delay2000ms()    //@22.1184MHz
 581          {
 582   1        unsigned char i, j, k;
 583   1      
 584   1        _nop_();
 585   1        _nop_();
 586   1        i = 169;
 587   1        j = 24;
 588   1        k = 59;
 589   1        do
 590   1        {
 591   2          do
 592   2          {
 593   3            while (--k);
 594   3          } while (--j);
 595   2        } while (--i);
 596   1      }
 597          
 598          /***********************************************
 599          函数名称：Delay_ms
 600          功    能：STC15系列单片机1ms延时程序
 601          入口参数：ms:延时的毫秒数
 602          返 回 值：无  
 603          备    注：示波器实测：0.997ms，内部时钟：11.0592MHz           
 604          ************************************************/
 605          void Delay_ms(unsigned int ms)
 606          {
 607   1        
C51 COMPILER V9.54   MAIN                                                                  12/22/2015 17:47:52 PAGE 11  

 608   1          unsigned int i;
 609   1          while( (ms--) != 0)
 610   1          {
 611   2            for(i = 0; i < 580; i++); 
 612   2          } 
 613   1        
 614   1      }
 615          void Delay200ms()     //@22.1184MHz
 616          {
 617   1        unsigned char i, j, k;
 618   1      
 619   1        _nop_();
 620   1        _nop_();
 621   1        i = 17;
 622   1        j = 208;
 623   1        k = 27;
 624   1        do
 625   1        {
 626   2          do
 627   2          {
 628   3            while (--k);
 629   3          } while (--j);
 630   2        } while (--i);
 631   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2272    ----
   CONSTANT SIZE    =    323    ----
   XDATA SIZE       =   1479      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      8       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)

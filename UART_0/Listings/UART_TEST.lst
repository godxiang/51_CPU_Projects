C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE UART_TEST
OBJECT MODULE PLACED IN .\Objects\UART_TEST.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE UART_TEST.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\UART_TEST.lst) TABS(2) OBJECT(.\Objects\UART_TEST.obj)

line level    source

   1          
   2          //包含文件定义
   3          //#include "reg51.h"
   4          //#include <stc.h>
   5          #include "stc15w4k32s4.h"
   6          #include "intrins.h"
   7          #include "string.h"
   8          //串口相关常量定义
   9          #define  FOSC              22118400L   //系统频率11059200L 22118400L
  10          #define  Uart1_MaxString   32          //串口1最大接收缓冲区字符数量(0-31)共32个字符
  11          #define  Uart2_MaxString   32          //串口2最大接收缓冲区字符数量(0-31)共32个字符
  12          //串口相关变量定义
  13          char           Uart1_Data[Uart1_MaxString];   //串口1接收字串
  14          unsigned char  Uart1_String_P;                //串口1接收字串位置指针
  15          bit            Uart1_busy;                    //串口1正在发送标记,1，正在发送，0，发送完成
  16          unsigned char  Uart1_ParitySet;               //串口1奇偶校验方式 0不校验 1奇校验 2偶校验 3始终1 4始终0
  17          bit            Uart1_Parity;                  //串口1接收到的奇偶校验状态 1,0
  18          bit            Uart1_Parity_out;              //串口1验证接收到的奇偶校验状态 1,验证,0验证错误
  19          char           Uart2_Data[Uart1_MaxString];   //串口2接收字串
  20          unsigned char  Uart2_String_P;                //串口2接收字串位置指针
  21          bit            Uart2_busy;                    //串口2正在发送标记,1，正在发送，0，发送完成
  22          unsigned char  Uart2_ParitySet;               //串口2奇偶校验方式 0不校验 1奇校验 2偶校验 3始终1 4始终0
  23          bit            Uart2_Parity;                  //串口2接收到的奇偶校验状态 1,0
  24          bit            Uart2_Parity_out;              //串口2验证接收到的奇偶校验状态 1,验证,0验证错误
  25          //Uart1包含函数申明
  26          void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx); //串口1波特率和时基源设置函数
  27          void Uart1_SendData(unsigned char Uart1_dat);                  //串口1单字符发送函数
  28          void Uart1_SendString(char *s);                          //串口1字符串发送函数
  29          //void Uart1_Isr() interrupt 4 using 1;                    //串口1中断服务函数
  30          void Uart2_Setup(unsigned long Uart2_Baud);              //串口2波特率
  31          void Uart2_SendData(unsigned char Uart2_dat);                  //串口2单字符发送函数
  32          void Uart2_SendString(char *s);                          //串口2字符串发送函数
  33          //void Uart1_Isr() interrupt 4 using 1;                    //串口2中断服务函数
  34          /*串口编程示范============================================================================
  35          Uart1_String_P=0;                //串口1接收字串下标归0
  36          Uart1_ParitySet=1;               //串口1使用9位可变波特率方式，校验方式为奇校验
  37          Uart1_Setup(9600,0);             //串口1波特率为9600bps，时基源选择定时器1
  38          Uart1_SendString("hello word");  //串口1发送数据，英文字母 hello word
  39          Uart2_String_P=0;                //串口2接收字串下标归0
  40          Uart2_ParitySet=1;               //串口2使用9位可变波特率方式，校验方式为奇校验
  41          Uart2_Setup(9600);               //串口2波特率为9600bps
  42          Uart2_SendString("hello word");  //串口2发送数据，英文字母 hello word
  43          =======================================================================================*/
  44          /*********************************************************
  45          ** 函数名称: void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx) 
  46          ** 功能描述: 初始化串口函数
  47          ** 输　  入: unsigned long Uart1_Baud,bit Uart1_Tx
  48          ** 输　  出: 无
  49          ** 全局变量: PCON,SCON,TMOD,AUXR,TCON,TH1,
  50          ** 调用模块: 
  51          ** 备    注:时钟为22118400Hz
  52                      参数1:波特率设置,300;600;1200;2400;4800;9600;19200
  53                      参数2:计数器选择,0,定时器1;1,独立波特率
  54          **********************************************************/
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 2   

  55          void Uart1_Setup(unsigned long Uart1_Baud,bit Uart1_Tx) 
  56          {
  57   1      unsigned int Uart1_Brt;
  58   1      //时基源设置-------------------------------------------------
  59   1      if(Uart1_Tx)
  60   1          {
  61   2      AUXR |= 0x01;  //串口1选择独立波特率发生器
  62   2      }
  63   1      else
  64   1          {
  65   2      AUXR &= 0xFE;  //串口1选择定时器1做波特率发生器
  66   2      }
  67   1      //校验方式设置-------------------------------------------------
  68   1      switch (Uart1_ParitySet)
  69   1          {//判断校验方式
  70   2          case 1:
  71   2              {//9位串口, 奇校验 Uart1_ParitySet=1;   //校验位初值状态标记置1
  72   3              SCON=0xD8;           //9位波特率可变,允许接收,TB8待发第9位初始置1
  73   3              break;
  74   3              }
  75   2          case 2:
  76   2              {//9位串口, 偶校验 Uart1_ParitySet=2;   //校验位初值状态标记置2
  77   3              SCON=0xD4;           //9位波特率可变,允许接收,RB8待收第9位初始置1
  78   3              break;
  79   3              }
  80   2          case 3:
  81   2              {//9位串口, 掩码校验 校验值始终为 1 Uart1_ParitySet=3;   //校验位初值状态标记置3
  82   3              SCON|=0xD8;         //9位波特率可变,允许接收,TB8待发第9位初始置1
  83   3              break;
  84   3              }
  85   2          case 4:
  86   2              {//9位串口, 空校验 校验值始终为 0 Uart1_ParitySet=4;   //校验位初值状态标记置4
  87   3              SCON=0xD4;          //9位波特率可变,允许接收,RB8待收第9位初始置1
  88   3              break;
  89   3              }
  90   2          default:
  91   2              {//8位串口, 无校验 Uart1_ParitySet=0;   //校验位初值状态标记置0
  92   3              SCON&=0x5F;         //清除第5位,第7位
  93   3              SCON|=0x50;         //8位波特率可变,允许接收
  94   3              break;
  95   3              }
  96   2          }
  97   1      //波特率设置并开始运行串口-------------------------------------------------
  98   1      //时钟为22118400Hz
  99   1      Uart1_Brt=FOSC/32/Uart1_Baud;
 100   1      if(Uart1_Brt>255)
 101   1          {//如果重装值>255,使用12T模式12分频
 102   2          if(Uart1_Tx)
 103   2              {//如果使用独立波特率发生器
 104   3              //PCON |= 0x80;                                 //串口1波特率加倍
 105   3              //PCON &= 0x7f;                                 //串口1波特率不加倍
 106   3              AUXR &= 0xFB;                                 //独立波特率使用12T模式
 107   3              //AUXR |= 0x04;                                 //独立波特率使用1T模式
 108   3              BRT = 256-Uart1_Brt/12;                       //独立波特率发生器初值设置
*** ERROR C202 IN LINE 108 OF UART_TEST.c: 'BRT': undefined identifier
 109   3              AUXR|= 0x10;                                  //独立波特率发生器开始计数
 110   3              }
 111   2          else
 112   2              {//如果使用定时器1做波特率发生器
 113   3              TMOD&=0xCF;                                 //清除定时器1设置状态，定时器0不修改
 114   3              TMOD|=0x20;                                 //定时器1使用8位自动重装模式
 115   3              //PCON |= 0x80;                               //串口1波特率加倍
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 3   

 116   3              //PCON &= 0x7f;                               //串口1波特率不加倍
 117   3              AUXR &= 0xBF;                               //定时器1使用12T模式
 118   3              //AUXR|=0x40;                                 //定时器1使用1T模式
 119   3              TH1  = TL1 = 256-Uart1_Brt/12;              //设置自动装入的值
 120   3              ET1  = 0;                                   //关闭定时器1中断
 121   3              TR1  = 1;                                   //TCON|=0x40;定时器1开始计数,TCON&=0xBF;关闭计数
 122   3              }
 123   2          }
 124   1      else
 125   1          {//如果重装值<255,使用1T模式1分频
 126   2          if(Uart1_Tx)
 127   2              {//如果使用独立波特率发生器
 128   3              //PCON |= 0x80;                                 //串口1波特率加倍
 129   3              //PCON &= 0x7f;                                 //串口1波特率不加倍
 130   3              //AUXR &= 0xFB;                                 //独立波特率使用12T模式
 131   3              AUXR |= 0x04;                                 //独立波特率使用1T模式
 132   3              BRT  = 256-Uart1_Brt;                         //独立波特率发生器初值设置
*** ERROR C202 IN LINE 132 OF UART_TEST.c: 'BRT': undefined identifier
 133   3              AUXR|= 0x10;                                  //独立波特率发生器开始计数
 134   3              }
 135   2          else
 136   2              {//如果使用定时器1做波特率发生器
 137   3              TMOD&=0xCF;                                 //清除定时器1设置状态，定时器0不修改
 138   3              TMOD|=0x20;                                 //定时器1使用8位自动重装模式
 139   3              //PCON |= 0x80;                               //串口1波特率加倍
 140   3              //PCON &= 0x7f;                               //串口1波特率不加倍
 141   3              //AUXR &= 0xBF;                               //定时器1使用12T模式
 142   3              AUXR|=0x40;                                 //定时器1使用1T模式
 143   3              TH1  = TL1 = 256-Uart1_Brt;                 //设置自动装入的值
 144   3              ET1  = 0;                                   //关闭定时器1中断
 145   3              TR1  = 1;                                   //TCON|=0x40;定时器1开始计数,TCON&=0xBF;关闭计数
 146   3              }
 147   2          }
 148   1          ES        = 1;                                  //打开串口中断
 149   1          EA        = 1;                                  //打开总中断
 150   1      }
 151          /*********************************************************
 152          ** 函数名称: void Uart2_Setup(unsigned long Uart2_Baud) 
 153          ** 功能描述: 初始化串口函数
 154          ** 输　  入: unsigned long Uart1_Baud
 155          ** 输　  出: 无
 156          ** 全局变量: 
 157          ** 调用模块: 
 158          ** 备    注:时钟为22118400Hz
 159                      参数1:波特率设置,300;600;1200;2400;4800;9600;19200
 160          **********************************************************/
 161          void Uart2_Setup(unsigned long Uart2_Baud) 
 162          {
 163   1      unsigned int Uart2_Brt;
 164   1      //校验方式设置-------------------------------------------------
 165   1      switch (Uart2_ParitySet)
 166   1          {//判断校验方式
 167   2          case 1:
 168   2              {//9位串口, 奇校验 Uart1_ParitySet=1;   //校验位初值状态标记置1
 169   3              S2CON=0xD8;           //9位波特率可变,允许接收,TB8待发第9位初始置1
 170   3              break;
 171   3              }
 172   2          case 2:
 173   2              {//9位串口, 偶校验 Uart1_ParitySet=2;   //校验位初值状态标记置2
 174   3              S2CON=0xD4;           //9位波特率可变,允许接收,RB8待收第9位初始置1
 175   3              break;
 176   3              }
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 4   

 177   2          case 3:
 178   2              {//9位串口, 掩码校验 校验值始终为 1 Uart1_ParitySet=3;   //校验位初值状态标记置3
 179   3              S2CON|=0xD8;         //9位波特率可变,允许接收,TB8待发第9位初始置1
 180   3              break;
 181   3              }
 182   2          case 4:
 183   2              {//9位串口, 空校验 校验值始终为 0 Uart1_ParitySet=4;   //校验位初值状态标记置4
 184   3              S2CON=0xD4;          //9位波特率可变,允许接收,RB8待收第9位初始置1
 185   3              break;
 186   3              }
 187   2          default:
 188   2              {//8位串口, 无校验 Uart1_ParitySet=0;   //校验位初值状态标记置0
 189   3              S2CON&=0x5F;         //清除第5位,第7位
 190   3              S2CON|=0x50;         //8位波特率可变,允许接收
 191   3              break;
 192   3              }
 193   2          }
 194   1      //波特率设置并开始运行串口-------------------------------------------------
 195   1      //时钟为22118400Hz
 196   1      Uart2_Brt=FOSC/32/Uart2_Baud;
 197   1      if(Uart2_Brt>255)
 198   1          {//如果重装值>255,使用12T模式12分频
 199   2              //PCON |= 0x80;                                 //串口1波特率加倍
 200   2              //PCON &= 0x7f;                                 //串口1波特率不加倍
 201   2              AUXR &= 0xFB;                                 //独立波特率使用12T模式
 202   2              //AUXR |= 0x04;                                 //独立波特率使用1T模式
 203   2              BRT = 256-Uart2_Brt/12;                       //独立波特率发生器初值设置
*** ERROR C202 IN LINE 203 OF UART_TEST.c: 'BRT': undefined identifier
 204   2          }
 205   1      else
 206   1          {//如果重装值<255,使用1T模式1分频
 207   2              //PCON |= 0x80;                                 //串口1波特率加倍
 208   2              //PCON &= 0x7f;                                 //串口1波特率不加倍
 209   2              //AUXR &= 0xFB;                                 //独立波特率使用12T模式
 210   2              AUXR |= 0x04;                                 //独立波特率使用1T模式
 211   2              BRT  = 256-Uart2_Brt;                         //独立波特率发生器初值设置
*** ERROR C202 IN LINE 211 OF UART_TEST.c: 'BRT': undefined identifier
 212   2          }
 213   1          AUXR|= 0x10;                                  //独立波特率发生器开始计数
 214   1      IE2|=0x01;                                    ////打开串口2中断
 215   1          EA   = 1;                                     //打开总中断
 216   1      }
 217          //=======================================================================================
 218          /**********************************************************
 219          串口1中断服务函数
 220          **********************************************************/
 221          void Uart1_Isr() interrupt 4 using 1
 222          {// UART 中断服务函数
 223   1      EA=0; //关总中断
 224   1      if (RI)
 225   1      {//如果 UART 接收产生中断
 226   2          RI = 0;                                           //清除 UART 接收中断标记
 227   2          ACC= SBUF;                                        //接收缓冲区数据写入累加器A
 228   2          Uart1_Parity = P;                                 //保存校验值到Uart1_Parity
 229   2          Uart1_Parity_out=0;                               //清除允许写入标记，为下面判断准备
 230   2          switch(Uart1_ParitySet)
 231   2          {//根据校验要求判断
 232   3              case 1:
 233   3              {//要求奇校验
 234   4              Uart1_Parity_out=Uart1_Parity^RB8;    //如果检验结果和接收结果不符合则成立，允许写入
 235   4              break;
 236   4              }
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 5   

 237   3              case 2:
 238   3              {//要求偶校验
 239   4              Uart1_Parity_out=~(Uart1_Parity^RB8); //如果检验结果和接收结果符合则成立，允许写入
 240   4              break;
 241   4              }
 242   3              case 3:
 243   3              {//要求常1校验
 244   4              Uart1_Parity_out=RB8;                 //如果接收结果为1则成立，允许写入
 245   4              break;
 246   4              }
 247   3              case 4:
 248   3              {//要求常0校验
 249   4              Uart1_Parity_out=~RB8;                //如果接收结果为0则成立，允许写入
 250   4              break;
 251   4              }
 252   3              default:
 253   3              {//要求无校验
 254   4              Uart1_Parity_out=1;                  //如果无校验，允许写入
 255   4              break;
 256   4              }
 257   3          }
 258   2          if(Uart1_Parity_out)
 259   2          {//如果允许写入
 260   3              Uart1_Data[Uart1_String_P]= SBUF;              //接收缓冲区数据顺序写入串口接收字串
 261   3              Uart1_String_P++;                              //串口接收字串指针累加
 262   3              //↓如果串口接收字串指针在大于最大接收缓冲区字符数量,串口接收字串指针归零
 263   3              if(Uart1_String_P >= Uart1_MaxString) 
 264   3              {//如果接受字串指针越界
 265   4                  Uart1_String_P=0;                          //接受字串指针归零
 266   4              }
 267   3          }
 268   2      }
 269   1      if (TI)
 270   1      {//如果 UART 发送产生中断
 271   2          TI   = 0;                  //清除 UART 发送中断标记
 272   2          Uart1_busy = 0;            //发送完成，清除正在发送标记
 273   2      }
 274   1      EA=1;                          //开总中断
 275   1      }
 276          //=======================================================================================
 277          /**********************************************************
 278          串口2中断服务函数
 279          **********************************************************/
 280          void Uart2_Isr() interrupt 8 using 1
 281          {// UART 中断服务函数
 282   1      EA=0; //关总中断
 283   1      if (S2CON&0x01)
 284   1      {//如果 UART 接收产生中断
 285   2          S2CON &= 0xFE;                                     //清除 UART 接收中断标记
 286   2          ACC= S2BUF;                                        //接收缓冲区数据写入累加器A
 287   2          Uart2_Parity = P;                                  //保存校验值到Uart1_Parity
 288   2          Uart2_Parity_out=0;                                //清除允许写入标记，为下面判断准备
 289   2          switch(Uart2_ParitySet)
 290   2          {//根据校验要求判断
 291   3              case 1:
 292   3              {//要求奇校验
 293   4              Uart2_Parity_out=Uart2_Parity^(S2CON&0x04);    //如果检验结果和接收结果不符合则成立，允许写入 (S2C
             -ON&0x04)==S2RB8
 294   4              break;
 295   4              }
 296   3              case 2:
 297   3              {//要求偶校验
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 6   

 298   4              Uart2_Parity_out=~(Uart2_Parity^(S2CON&0x04)); //如果检验结果和接收结果符合则成立，允许写入
 299   4              break;
 300   4              }
 301   3              case 3:
 302   3              {//要求常1校验
 303   4              Uart2_Parity_out=(S2CON&0x04);                 //如果接收结果为1则成立，允许写入
 304   4              break;
 305   4              }
 306   3              case 4:
 307   3              {//要求常0校验
 308   4              Uart2_Parity_out=~(S2CON&0x04);                //如果接收结果为0则成立，允许写入
 309   4              break;
 310   4              }
 311   3              default:
 312   3              {//要求无校验
 313   4              Uart2_Parity_out=1;                  //如果无校验，允许写入
 314   4              break;
 315   4              }
 316   3          }
 317   2          if(Uart2_Parity_out)
 318   2          {//如果允许写入
 319   3              Uart2_Data[Uart2_String_P]= S2BUF;              //接收缓冲区数据顺序写入串口接收字串
 320   3              Uart2_String_P++;                              //串口接收字串指针累加
 321   3              //↓如果串口接收字串指针在大于最大接收缓冲区字符数量,串口接收字串指针归零
 322   3              if(Uart2_String_P >= Uart2_MaxString) 
 323   3              {//如果接受字串指针越界
 324   4                  Uart2_String_P=0;                          //接受字串指针归零
 325   4              }
 326   3          }
 327   2      }
 328   1      if (S2CON&0x02)
 329   1      {//如果 UART 发送产生中断
 330   2          S2CON &= 0xFD;                  //清除 UART 发送中断标记
 331   2          Uart2_busy = 0;            //发送完成，清除正在发送标记
 332   2      }
 333   1      EA=1;                          //开总中断
 334   1      }
 335          
 336          //=======================================================================================
 337          /**********************************************************
 338          ** 函数名称: void Uart1_SendData(unsigned char Uart1_dat)
 339          ** 功能描述: UART1 单个字符发送函数
 340          ** 输　  入: unsigned char Uart1_dat
 341          ** 输　  出: 无
 342          ** 全局变量: 
 343          ** 调用模块: 
 344          ** 备    注:参数1:待发送的单个字符
 345          **********************************************************/
 346          void Uart1_SendData(unsigned char Uart1_dat)
 347          {//UART 发送字节函数
 348   1          while (Uart1_busy);       //循环等待正在发送标记被清空
 349   1          ACC = Uart1_dat;                //被发送数据送累加器A,准备求奇偶校验位 P
 350   1          TB8 = P;                  //写奇偶校验标记
 351   1          switch(Uart1_ParitySet)
 352   1          {//根据校验要求判断
 353   2              case 1:
 354   2              {//要求奇校验
 355   3                  TB8=~TB8;        //翻转TB8的值
 356   3                  break;
 357   3              }
 358   2              /*偶校验，TB8不变
 359   2              case 2:
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 7   

 360   2              {//要求偶校验
 361   2                  TB8=TB8;            //TB8不变
 362   2                  break;
 363   2              }
 364   2              */
 365   2              case 3:
 366   2              {//要求常1校验
 367   3                  TB8=1;            //TB8恒等于1
 368   3                  break;
 369   3              }
 370   2              case 4:
 371   2              {//要求常0校验
 372   3                  TB8=0;            //TB8恒等于0
 373   3                  break;
 374   3              }
 375   2              default:
 376   2              {//要求无校验
 377   3              break;
 378   3              }
 379   2          }
 380   1          Uart1_busy = 1;          //正在发送标记置 1
 381   1          SBUF = ACC;              //累加器 A 中的数据送发送缓冲区发送
 382   1      }
 383          //=======================================================================================
 384          /**********************************************************
 385          ** 函数名称: void Uart2_SendData(unsigned char Uart2_dat)
 386          ** 功能描述: UART2 单个字符发送函数
 387          ** 输　  入: unsigned char Uart2_dat
 388          ** 输　  出: 无
 389          ** 全局变量: 
 390          ** 调用模块: 
 391          ** 备    注:参数1:待发送的单个字符
 392          **********************************************************/
 393          void Uart2_SendData(unsigned char Uart2_dat)
 394          {//UART 发送字节函数
 395   1          while (Uart2_busy);       //循环等待正在发送标记被清空
 396   1          ACC = Uart2_dat;                //被发送数据送累加器A,准备求奇偶校验位 P
 397   1          TB8 = P;                  //写奇偶校验标记
 398   1          switch(Uart2_ParitySet)
 399   1          {//根据校验要求判断
 400   2              case 1:
 401   2              {//要求奇校验
 402   3                  S2CON^=0x08;        //翻转S2TB8的值
 403   3                  break;
 404   3              }
 405   2              /*偶校验，S2TB8不变
 406   2              case 2:
 407   2              {//要求偶校验
 408   2                  S2TB8=1;            //S2TB8不变
 409   2                  break;
 410   2              }
 411   2              */
 412   2              case 3:
 413   2              {//要求常1校验
 414   3                  S2CON|=0x08;            //S2TB8恒等于1
 415   3                  break;
 416   3              }
 417   2              case 4:
 418   2              {//要求常0校验
 419   3                  S2CON&=0xF7;            //TB8恒等于0
 420   3                  break;
 421   3              }
C51 COMPILER V9.54   UART_TEST                                                             12/04/2015 15:05:28 PAGE 8   

 422   2              default:
 423   2              {//要求无校验
 424   3              break;
 425   3              }
 426   2          }
 427   1          Uart2_busy = 1;          //正在发送标记置 1
 428   1          S2BUF = ACC;              //累加器 A 中的数据送发送缓冲区发送
 429   1      }
 430          //=======================================================================================
 431          /**********************************************************
 432          ** 函数名称: void Uart1_SendString(char *s)
 433          ** 功能描述: UART1 按字符串发送函数
 434          ** 输　  入: char *s
 435          ** 输　  出: 无
 436          ** 全局变量: 
 437          ** 调用模块: 
 438          ** 备    注:参数1:待发送的字符串
 439          **********************************************************/
 440          void Uart1_SendString(char *s)
 441          {//UART 按字符串发送
 442   1          while (*s)
 443   1          {
 444   2              Uart1_SendData(*s++);   //将待发字符串依次使用SendData函数按字节发送
 445   2          }
 446   1      }
 447          //=======================================================================================
 448          /**********************************************************
 449          ** 函数名称: void Uart2_SendString(char *s)
 450          ** 功能描述: UART2 按字符串发送函数
 451          ** 输　  入: char *s
 452          ** 输　  出: 无
 453          ** 全局变量: 
 454          ** 调用模块: 
 455          ** 备    注:参数1:待发送的字符串
 456          **********************************************************/
 457          void Uart2_SendString(char *s)
 458          {//UART 按字符串发送
 459   1          while (*s)
 460   1          {
 461   2              Uart2_SendData(*s++);   //将待发字符串依次使用SendData函数按字节发送
 462   2          }
 463   1      }
 464          //=======================================================================================
 465          /*常用串口设置开关===============================副录===================================
 466          AUXR |= 0x01;  //串口1选择独立波特率发生器
 467          AUXR &= 0xFE;  //串口1选择定时器1做波特率发生器
 468          AUXR |= 0x40;  //定时器1使用1T模式
 469          AUXR &= 0xBF;  //定时器1使用12T模式
 470          AUXR |= 0x04;  //独立波特率使用1T模式
 471          AUXR &= 0xFB;  //独立波特率使用12T模式
 472          AUXR |= 0x10;  //打开独立波特率发生器
 473          AUXR &= 0xEF;  //关闭独立波特率发生器
 474          PCON |= 0x80;  //串口1波特率加倍
 475          PCON &= 0x7f;  //串口1波特率不加倍
 476          AUXR |= 0x08;   //串口2波特率加倍
 477          AUXR &= 0xf7;   //串口2波特率不加倍
 478          =======================================================================================*/

C51 COMPILATION COMPLETE.  0 WARNING(S),  4 ERROR(S)

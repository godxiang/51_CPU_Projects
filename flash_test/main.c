 //文件包含
 #include "stc15w4k32s4.h"
 #include "w25q64.h"
 #include "uart.h"

 //定义W25Q64的读写地址
 #define  FLASH_WriteAddress     0x000000			//写地址
 #define  FLASH_ReadAddress      FLASH_WriteAddress	//读地址
 #define  FLASH_SectorToErase    FLASH_WriteAddress	//擦除地址

 //数据缓冲区	页大小
 unsigned char  BufferData[sFLASH_SPI_PAGESIZE];

 //定义错误类型
 #define		ERR1			"1"
 #define		ERR2			"2"

 //测试数据，256个字节
 unsigned char code TestData[sFLASH_SPI_PAGESIZE] =
 {
    0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,
	0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,0x29,0x2a,0x2b,0x2c,0x2d,0x2e,0x2f,
	0x30,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x38,0x39,0x3a,0x3b,0x3c,0x3d,0x3e,0x3f,
	0x40,0x41,0x42,0x43,0x44,0x45,0x46,0x47,0x48,0x49,0x4a,0x4b,0x4c,0x4d,0x4e,0x4f,
	0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,0x58,0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0x5f,
	0x60,0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6a,0x6b,0x6c,0x6d,0x6e,0x6f,
	0x70,0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7a,0x7b,0x7c,0x7d,0x7e,0x7f,
	0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,0x8b,0x8c,0x8d,0x8e,0x8f,
	0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,
	0xa0,0xa1,0xa2,0xa3,0xa4,0xa5,0xa6,0xa7,0xa8,0xa9,0xaa,0xab,0xac,0xad,0xae,0xaf,
	0xb0,0xb1,0xb2,0xb3,0xb4,0xb5,0xb6,0xb7,0xb8,0xb9,0xba,0xbb,0xbc,0xbd,0xbe,0xbf,
	0xc0,0xc1,0xc2,0xc3,0xc4,0xc5,0xc6,0xc7,0xc8,0xc9,0xca,0xcb,0xcc,0xcd,0xce,0xcf,
	0xd0,0xd1,0xd2,0xd3,0xd4,0xd5,0xd6,0xd7,0xd8,0xd9,0xda,0xdb,0xdc,0xdd,0xde,0xdf,
	0xe0,0xe1,0xe2,0xe3,0xe4,0xe5,0xe6,0xe7,0xe8,0xe9,0xea,0xeb,0xec,0xed,0xee,0xef,
	0xf0,0xf1,0xf2,0xf3,0xf4,0xf5,0xf6,0xf7,0xf8,0xf9,0xfa,0xfb,0xfc,0xfd,0xfe,0xff,
 };
	 
 //函数声明
 void IO_Init(void);
 void Delay_ms(unsigned int ms);

 //主方法
 void main(void)
 {
 	unsigned int ID;
	unsigned int Cnt;
	IO_Init();		   		//端口初始化
	InitUart();
	Uart1SendString("Start!");

	Delay_ms(100);			//等待上电稳定
	ID=sFLASH_ReadID();		//读取W25Q64的器件ID号
	//如果ID号不同
	if(ID!=sFLASH_W25Q64_ID)
	{
		Uart1SendString(ERR1);
		//ToDisplayError(ERR1);//显示错误信息
		
		while(1);	
	}


	//显示读取到的W25Q64器件ID号
	/*
	  实际运行看不到显示的ID号,因为程序继续往下运行，
	  将显示后面的ToDisplayCorrect();如果需要显示ID号，
	  将后面的ToDisplayCorrect();这条语句注释掉。
	  */
	//ToDisplayBuf(ID);
	Uart1SendString("Start Read Write Test!\n");
	Uart1SendString("Erase!\n");
	Delay_ms(100);
	//写之前需先擦除，擦除一个扇区
	sFLASH_EraseSector(FLASH_SectorToErase);
	Uart1SendString("Write!\n");
	Delay_ms(300);
	//写入一页的数据
	sFLASH_WritePage(TestData,FLASH_WriteAddress,sFLASH_SPI_PAGESIZE);
	Uart1SendString("Read!\n");
	Delay_ms(300);
	//将该页的数据读出
	sFLASH_ReadBuffer(BufferData,FLASH_ReadAddress,sFLASH_SPI_PAGESIZE);
	//比较写入和读取的数据是否一致
	for(Cnt=0;Cnt<sFLASH_SPI_PAGESIZE;Cnt++) 
	{
		Uart1SendData(BufferData[Cnt]);
		//如果有数据不同
		if(TestData[Cnt]!=BufferData[Cnt])
		{			
			//ToDisplayError(ERR2);//显示错误信息
			Uart1SendString(ERR2);
			while(1);			
		}	
	}	
	//显示测试正确信息
	//ToDisplayCorrect();
	Uart1SendString("ID Success!");
 	while(1)
	{				
	}
 }
/***********************************************
函数名称：Delay_ms
功    能：STC15系列单片机1ms延时程序
入口参数：ms:延时的毫秒数
返 回 值：无	
备    注：示波器实测：0.997ms，内部时钟：11.0592MHz           
************************************************/
void Delay_ms(unsigned int ms)
{
  
  	unsigned int i;
  	while( (ms--) != 0)
   	{
    	for(i = 0; i < 580; i++); 
   	} 
	
}
/***********************************************
函数名称：IO_Init
功    能：单片机IO端口模式初始化
入口参数：无
返 回 值：无	
备    注：STC15W4K32S4系列A版单片机部分端口复位后
          不是准双向口,需要设置才能正常使用
************************************************/
void IO_Init(void)
{
  	//初始化P25,P26,P27口为准双向口
	//P0M1 &=~( (1<<5) | (1<<6) | (1<<7) );  
	//P0M0 &=~( (1<<5) | (1<<6) | (1<<7) );  

	//将P04 P05 P06 P07设置为开漏口
	//因为单片机为5V端口，W25Q64为3.3V端口，为了实现电平匹配
	//将单片机设置为开漏结构，由外部上拉到3.3V。
	P0M1 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;  
	P0M0 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;

	//分析
	//  1<<0等价于0x01 即 0000 0001
	//  1<<1等价于0x02 即 0000 0010
	//  1<<2等价于0x04 即 0000 0100
	//  1<<3等价于0x08 即 0000 1000
	//  以此类推1<<n 即第n位为1，其余位是0

	//  x |=(1<<n)  即对x执行按位取或 
	//  即x中的第n位置为1，不改变其他位状态  
	
	//  y &=~(1<<n)  即将1<<n按位取反，然后对y按位取与 
	//  即y中的第n位置为0，不改变其他位状态  
	
	//P10 P14复位后为强推挽输出、强上拉，
	//防止不当操作导致端口损坏，初始化为准双向口 
	//将P10 P14设置为准双向口
	//P1M1 &=~( (1<<0) | (1<<4) );  
	//P1M0 &=~( (1<<0) | (1<<4) );     
}															



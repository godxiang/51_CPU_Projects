C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1           //文件包含
   2          #include "stc15w4k32s4.h"
   3          #include "w25q64.h"
   4          
   5          #define FOSC 22118400L          //时钟频率
   6          #define BAUD 115200             //波特率
   7          #define S4RI  0x01              //S4CON.0
   8          #define S4TI  0x02              //S4CON.1
   9          #define S4_S0 0x04              //P_SW2.2
  10          #define S1_S0 0x40              //P_SW1.6
  11          #define S1_S1 0x80              //P_SW1.7
  12          
  13          void init_Uart();
  14          void IO_Init(void);
  15          void Uart1SendData(unsigned char dat);
  16          void Uart1SendString(char *s);
  17          void Uart4SendData(unsigned char Udat);
  18          void Uart4SendString(char *s);
  19          void Uart4_Process(void);
  20          void Delay_ms(unsigned int ms);
  21          void Delay1000ms();
  22          void Delay200ms();
  23          
  24          struct Re_FindCard{
  25          unsigned char Seccess_tag[8];
  26          unsigned char Failure_tag[4];
  27          };
  28          
  29          struct Re_SelectCard{
  30          unsigned char Seccess_tag[12];
  31          unsigned char Failure_tag[4];
  32          };
  33          
  34          struct Re_ReadCard{
  35          unsigned char Seccess_tag[3];
  36          unsigned char Failure_tag[4];
  37          };
  38          
  39          struct re_data{
  40          unsigned char header[5];
  41          struct Re_FindCard Re_FindCard_Data;
  42          struct Re_SelectCard Re_SelectCard_Data;
  43          struct Re_ReadCard Re_ReadCard_Data;
  44          }Re_Data={
  45          {0xaa,0xaa,0xaa,0x96,0x69},
  46          {{0x00, 0x00, 0x9f, 0x00, 0x00, 0x00, 0x00, 0x97},{0x00, 0x00, 0x80, 0x84}},
  47          {{0x00, 0x00, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9C},{0x00, 0x00, 0x81, 0x85}},
  48          {{0x00, 0x00, 0x90},{0x00, 0x00, 0x41, 0x45}}
  49          };
  50          
  51          unsigned char xdata re_data_buffer[1295];
  52          unsigned  int i=0,Re_num=0;
  53          unsigned char const code FIND_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x01, 0x22};
  54          unsigned char const code SELECT_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x02, 0x21};
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 2   

  55          unsigned char const code READ_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x30, 0x01, 0x32};
  56          //unsigned char const code TestData[10] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
  57          //unsigned char OpCart_FindCart(void);
  58          //unsigned char OpCart_SelectCart(void);
  59          //unsigned char OpCart_ReadCart(void);
  60          bit Uart4busy;
  61          bit Uart1busy;
  62          
  63          
  64          void main(void)
  65            {
  66   1          unsigned int n,Cnt,ID;
  67   1          init_Uart();
  68   1          IO_Init();
  69   1          for (n=0;n<10;n++){
  70   2            Uart4SendData(FIND_CARD[n]);  
  71   2          }
  72   1              //Uart4_Process();
  73   1          Delay200ms();     //等待接收数据
  74   1          Re_num=0;
  75   1          for (n=0;n<10;n++){
  76   2            Uart4SendData(SELECT_CARD[n]);  
  77   2          }
  78   1              //Uart4_Process();  
  79   1          Delay200ms();     //等待接收数据
  80   1          Re_num=0;
  81   1          for (n=0;n<10;n++){
  82   2            Uart4SendData(READ_CARD[n]);  
  83   2          } 
  84   1          Delay1000ms();    //等待上电稳定(接收数据)
  85   1          Delay1000ms();
  86   1          ID=sFLASH_ReadID();             //读取W25Q64的器件ID号                                    
  87   1          if(ID!=sFLASH_W25Q64_ID)        //如果ID号不同
  88   1          {
  89   2            Uart1SendString("ID ERROR!");
  90   2            while(1); 
  91   2          }
  92   1      
  93   1        Uart1SendString("Start Read Write Test!\n");
  94   1        Uart1SendString("Erase!\n");
  95   1        Delay_ms(100);
  96   1        //写之前需先擦除，擦除一个扇区
  97   1        sFLASH_EraseSector(FLASH_SectorToErase);
  98   1        Uart1SendString("Write!\n");
  99   1        Delay_ms(300);
 100   1        //写入一页的数据
 101   1        sFLASH_WritePage(re_data_buffer,FLASH_WriteAddress,Re_num);
 102   1        Uart1SendString("Read!\n");
 103   1        Delay_ms(300);
 104   1        //将该页的数据读
 105   1        sFLASH_ReadBuffer(re_data_buffer,FLASH_ReadAddress,Re_num);
 106   1        //比较写入和读取的数据是否一致
 107   1        for(Cnt=0;Cnt<Re_num;Cnt++) 
 108   1        {
 109   2          Uart1SendData(re_data_buffer[Cnt]);
 110   2          //如果有数据不同
 111   2          /*if(TestData[Cnt]!=re_data_buffer[Cnt])
 112   2          {     
 113   2            //ToDisplayError(ERR2);//显示错误信息
 114   2            Uart1SendString("Read Error!");
 115   2            while(1);     
 116   2          } */
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 3   

 117   2        } 
 118   1          Uart1SendString("Success!");
 119   1          while(1);
 120   1            //Uart4_Process();    
 121   1      }
 122          /*****************************************/
 123          /* 串口4初始化                           */
 124          /* 程序功能：串口4初始化                 */
 125          /* 入口参数:无                           */
 126          /* 出口参数:无                           */
 127          /*****************************************/
 128          void init_Uart()
 129            {
 130   1          P_SW2 &= ~S4_S0;            //S4_S0=0 (P0.2/RxD4, P0.3/TxD4)
 131   1          ACC = P_SW1;
 132   1          ACC &= ~(S1_S0 | S1_S1);    //S1_S0=0 S1_S1=0
 133   1          P_SW1 = ACC;                //(P3.0/RxD, P3.1/TxD)
 134   1          SCON = 0x50;                //1010000
 135   1          S4CON = 0x10;               //10000
 136   1          T2L = (65536 - (FOSC/4/BAUD));   //设置波特率重装值
 137   1          T2H = (65536 - (FOSC/4/BAUD))>>8;
 138   1          AUXR = 0x14;                //T2为1T模式, 并启动定时器2 10100
 139   1          AUXR |= 0x01;               //选择定时器2为串口1的波特率发生器
 140   1          ES = 1;                     //使能串口1中断
 141   1          IE2 = 0x10;                 //使能串口4中断
 142   1          EA = 1;
 143   1      }
 144          
 145          /*----------------------------
 146          UART4 中断服务程序
 147          -----------------------------*/
 148          void Uart4_ISR() interrupt 18 using 1
 149          {
 150   1        unsigned char dat;
 151   1        EA=0;
 152   1        dat = S4BUF;
 153   1            if (S4CON & S4RI)
 154   1          {
 155   2            if(Re_num<1295){      
 156   3            re_data_buffer[Re_num++]=dat;
 157   3            }
 158   2              S4CON &= ~S4RI;                               //串口接收中断标记需软件清零
 159   2          }
 160   1              
 161   1          
 162   1          if (S4CON & S4TI)
 163   1          {
 164   2            S4CON&= ~S4TI;
 165   2            Uart4busy=0;
 166   2          }
 167   1        EA=1;
 168   1      }
 169          /***********************************************
 170          *函数名称：Uart4_Process
 171          *功    能：串口命令处理函数
 172          *入口参数：无
 173          *返 回 值：无 
 174          *备    注：无
 175          ************************************************/
 176          void Uart4_Process(void)  
 177          {
 178   1        unsigned char j;
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 4   

 179   1            //for(;j<5;j++)
 180   1            //while (re_data_buffer[j] != Re_Data.header[j])  //判断接收数据头，5个字节
 181   1              //Uart1SendString("Received Data Error!");
 182   1            //Uart1SendData(0x01);
 183   1            //j=0;                                            //数据指针归零
 184   1              if (re_data_buffer[5]==0x00){
 185   2                
 186   2                  if (re_data_buffer[6] == 0x04){
 187   3                        unsigned char a=7,b=0;
 188   3                        unsigned char temp[3]={0,0,0};
 189   3                          for(;a<11,b<4;a++,b++){
 190   4                          if(re_data_buffer[a] == Re_Data.Re_FindCard_Data.Failure_tag[b])
 191   4                            temp[0]++;
 192   4                          if(re_data_buffer[a] == Re_Data.Re_SelectCard_Data.Failure_tag[b])
 193   4                            temp[1]++;
 194   4                          if(re_data_buffer[a] == Re_Data.Re_ReadCard_Data.Failure_tag[b])
 195   4                            temp[2]++;
 196   4                    }
 197   3                    if(temp[0] == 4){
 198   4                      //Uart1SendString("FindCard!\n");
 199   4                    for(j=0;j<11;j++);
 200   4                    //Uart1SendData(re_data_buffer[j]);     
 201   4                    }
 202   3                    if(temp[1] == 4){
 203   4                      //Uart1SendString("SelectCard!\n");
 204   4                    for(j=0;j<11;j++);
 205   4                    //Uart1SendData(re_data_buffer[j]);
 206   4                    }
 207   3                    if(temp[2] == 4)
 208   3                      //Uart1SendString("ReadCard!\n");
 209   3                    for(j=0;j<11;j++);
 210   3                    //Uart1SendData(re_data_buffer[j]);
 211   3                    }
 212   2                  else if (re_data_buffer[6]==0x08)
 213   2                  for(j=0;j<15;j++);
 214   2                    //Uart1SendData(re_data_buffer[j]);
 215   2                  else if (re_data_buffer[6]==0x0c)
 216   2                    for(j=0;j<19;j++);
 217   2                    //Uart1SendData(re_data_buffer[j]);
 218   2                  }
 219   1              else if(re_data_buffer[5]==0x05){
 220   2                  //Uart1SendString("ID INFO START!\n");
 221   2                for(j=0;j<300;j++)
 222   2                Uart1SendData(re_data_buffer[j]);
 223   2              }
 224   1              i=0;
 225   1      }
 226          /*----------------------------------
 227          16进制转换函数
 228          
 229          -----------------------------------*/
 230          unsigned char htd(unsigned char a){
 231   1      unsigned char b,c;
 232   1        b=a%10;
 233   1        c=b;
 234   1        a=a/10;
 235   1        b=a%10;
 236   1        c=c|b>>4;
 237   1        return c;
 238   1      }
 239          /*----------------------------
 240          串口4发送数据
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 5   

 241          ----------------------------*/
 242          void Uart4SendData(unsigned char Udat)
 243          {
 244   1        while(Uart4busy);
 245   1        ACC = Udat;
 246   1        Uart4busy=1;
 247   1        S4BUF = ACC;
 248   1      }
 249          
 250          
 251          void Uart4SendString(char *s)
 252          {
 253   1          while (*s)                 
 254   1          {
 255   2               Uart4SendData(*s++);         
 256   2          }
 257   1      }
 258          /*****************************************
 259          身份证操作寻卡                        
 260          入口参数:无                         
 261          出口参数:无                          
 262          *****************************************/
 263          /*
 264          unsigned char OpCart_FindCard(void)
 265            {
 266                unsigned char const FIND_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x01, 0x22};
 267                unsigned char Response[15];
 268                unsigned char Res_i=0;
 269                unsigned char OpCart_FindCard_i=0;
 270                while(OpCart_FindCard_i<10){
 271                Uart4SendData(FIND_CARD[OpCart_FindCard_i]);
 272                OpCart_FindCard_i++;
 273              }
 274          }*/
 275          /*****************************************
 276          身份证操作选卡                         
 277          程序功能：身份证选卡操作              
 278          入口参数:无                          
 279          出口参数:无                           
 280          *******************************************/
 281          /*
 282          unsigned char OpCart_SelectCard(void){
 283                unsigned char SELECT_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x20, 0x02, 0x21};
 284                unsigned char SELECT_CARD_RESPONSE[15]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x0c, 0x00, 0x00, 0x9F, 0x0
             -0, 0x00, 0x00, 0x00, 0x97};
 285                unsigned char Response[15];
 286                unsigned char Res_i=0;
 287                unsigned char OpCart_SelectCard_i=0;
 288                while(OpCart_SelectCard_i<10){
 289                Uart4SendData(SELECT_CARD[OpCart_SelectCard_i++]);//发送数据
 290              }
 291                while(!(S4CON&0x01));
 292                Response[Res_i++]=S4BUF;                          //接收模块的数据并保存
 293                if(SELECT_CARD_RESPONSE[Res_i]==Response[Res_i])
 294                S4CON&=~0x01;
 295          }*/
 296          /*****************************************
 297          身份证操作读卡                           
 298          程序功能：身份证读卡操作              
 299          入口参数:无                          
 300          出口参数:无                         
 301          *****************************************/
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 6   

 302          /*unsigned char OpCart_ReadCard(void){
 303            
 304                unsigned char READ_CARD[10]={0xaa, 0xaa, 0xaa, 0x96, 0x69, 0x00, 0x03, 0x30, 0x01, 0x32};
 305                unsigned char OpCart_ReadCard_i=0;
 306                while(OpCart_ReadCard_i<10){
 307                Uart4SendData(READ_CARD[OpCart_ReadCard_i]);
 308                OpCart_ReadCard_i++;
 309              }
 310          }*/
 311          /*----------------------------
 312          UART 中断服务程序
 313          -----------------------------*/
 314          void Uart1_ISR() interrupt 4 using 1
 315          {
 316   1        EA=0;
 317   1          if (RI)
 318   1          {
 319   2              RI = 0;                 //清除RI位
 320   2          }
 321   1          if (TI)
 322   1          {
 323   2              TI = 0;                 //清除TI位
 324   2              Uart1busy = 0;               //清忙标志
 325   2          }
 326   1        EA=1;
 327   1      }
 328          
 329          /*----------------------------
 330          发送串口数据
 331          ----------------------------*/
 332          void Uart1SendData(unsigned char dat)
 333          {
 334   1          while (Uart1busy);               //等待前面的数据发送完成
 335   1          Uart1busy = 1;
 336   1          SBUF = dat;                 //写数据到UART数据寄存器
 337   1      }
 338          
 339          /*----------------------------
 340          发送字符串
 341          ----------------------------*/
 342          void Uart1SendString(char *s)
 343          {
 344   1          while (*s)                  //检测字符串结束标志
 345   1          {
 346   2              Uart1SendData(*s++);         //发送当前字符
 347   2          }
 348   1      }
 349          
 350          
 351          /***********************************************
 352          函数名称：IO_Init
 353          功    能：单片机IO端口模式初始化
 354          入口参数：无
 355          返 回 值：无  
 356          备    注：STC15W4K32S4系列A版单片机部分端口复位后
 357                    不是准双向口,需要设置才能正常使用
 358          ************************************************/
 359          void IO_Init(void)
 360          {
 361   1      
 362   1        //将P04 P05 P06 P07设置为开漏口
 363   1        //因为单片机为5V端口，W25Q64为3.3V端口，为了实现电平匹配
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 7   

 364   1        //将单片机设置为开漏结构，由外部上拉到3.3V。
 365   1        
 366   1        P0M1 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;  
 367   1        P0M0 |= (1<<4) | (1<<5) | (1<<6) | (1<<7) ;
 368   1      
 369   1        //分析
 370   1        //  1<<0等价于0x01 即 0000 0001
 371   1        //  1<<1等价于0x02 即 0000 0010
 372   1        //  1<<2等价于0x04 即 0000 0100
 373   1        //  1<<3等价于0x08 即 0000 1000
 374   1        //  以此类推1<<n 即第n位为1，其余位是0
 375   1      
 376   1        //  x |=(1<<n)  即对x执行按位取或 
 377   1        //  即x中的第n位置为1，不改变其他位状态  
 378   1        
 379   1        //  y &=~(1<<n)  即将1<<n按位取反，然后对y按位取与 
 380   1        //  即y中的第n位置为0，不改变其他位状态  
 381   1        
 382   1        //P10 P14复位后为强推挽输出、强上拉，
 383   1        //防止不当操作导致端口损坏，初始化为准双向口 
 384   1        //将P10 P14设置为准双向口
 385   1        //P1M1 &=~( (1<<0) | (1<<4) );  
 386   1        //P1M0 &=~( (1<<0) | (1<<4) );     
 387   1      }                             
 388          
 389          
 390          
 391          
 392          void Delay1000ms()    //@22.1184MHz
 393          {
 394   1        unsigned char i, j, k;
 395   1      
 396   1        _nop_();
 397   1        _nop_();
 398   1        i = 85;
 399   1        j = 12;
 400   1        k = 155;
 401   1        do
 402   1        {
 403   2          do
 404   2          {
 405   3            while (--k);
 406   3          } while (--j);
 407   2        } while (--i);
 408   1      }
 409          /***********************************************
 410          函数名称：Delay_ms
 411          功    能：STC15系列单片机1ms延时程序
 412          入口参数：ms:延时的毫秒数
 413          返 回 值：无  
 414          备    注：示波器实测：0.997ms，内部时钟：11.0592MHz           
 415          ************************************************/
 416          void Delay_ms(unsigned int ms)
 417          {
 418   1        
 419   1          unsigned int i;
 420   1          while( (ms--) != 0)
 421   1          {
 422   2            for(i = 0; i < 580; i++); 
 423   2          } 
 424   1        
 425   1      }
C51 COMPILER V9.54   MAIN                                                                  12/13/2015 13:07:23 PAGE 8   

 426          void Delay200ms()   //@22.1184MHz
 427          {
 428   1        unsigned char i, j, k;
 429   1      
 430   1        _nop_();
 431   1        _nop_();
 432   1        i = 17;
 433   1        j = 208;
 434   1        k = 27;
 435   1        do
 436   1        {
 437   2          do
 438   2          {
 439   3            while (--k);
 440   3          } while (--j);
 441   2        } while (--i);
 442   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1109    ----
   CONSTANT SIZE    =     99    ----
   XDATA SIZE       =   1339      16
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
